#include <olectl.h>

import "oaidl.idl";
import "ocidl.idl";

[
    uuid(12137080-A1CB-11d3-B16A-0008C76BE5B9),
    version(1.0),
    helpstring("Vibration Control Type Library")
]
library VIBECTRLLib
{
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
        object,
        uuid(12137083-A1CB-11d3-B16A-0008C76BE5B9),
        dual,
        helpstring("IVibrationControl Interface"),
        pointer_default(unique)
    ]
    interface IVibrationControl : IDispatch
    {
        [id(1), helpstring("Method: Scan")] HRESULT Scan();

        [id(2), helpstring("Method: IsPluggedIn")] HRESULT IsPluggedIn([in]short nPort, [in]short nDevice, [out, retval]VARIANT_BOOL *pbPlugged);
        [id(3), helpstring("Method: GetNumberOfSources")] HRESULT GetNumberOfSources([in]short nPort, [in]short nDevice, [out, retval]short *pnSources);
        [id(4), helpstring("Method: GetNumberOfSimultaneousSources")] HRESULT GetNumberOfSimultaneousSources([in]short nPort, [in]short nDevice, [out, retval]short *pnSimSources);

        [id(5), helpstring("Method: GetMinimumFrequency")] HRESULT GetMinimumFrequency([in]short nPort, [in]short nDevice, [in]short nSource, [out, retval]double *pfFreq);
        [id(6), helpstring("Method: GetMaximumFrequency")] HRESULT GetMaximumFrequency([in]short nPort, [in]short nDevice, [in]short nSource, [out, retval]double *pfFreq);
        [id(7), helpstring("Method: GetAxisOfVibration")] HRESULT GetAxisOfVibration([in]short nPort, [in]short nDevice, [in]short nSource, [out, retval]BSTR *pbstrAxis);
        [id(8), helpstring("Method: GetPosition")] HRESULT GetPosition([in]short nPort, [in]short nDevice, [in]short nSource, [out, retval]BSTR *pbstrPos);
        [id(9), helpstring("Method: HasVariableIntensityCapability")] HRESULT HasVariableIntensityCapability([in]short nPort, [in]short nDevice, [in]short nSource, [out, retval]VARIANT_BOOL *pbCap);
        [id(10), helpstring("Method: HasContinuousVibrationCapability")] HRESULT HasContinuousVibrationCapability([in]short nPort, [in]short nDevice, [in]short nSource, [out, retval]VARIANT_BOOL *pbCap);
        [id(11), helpstring("Method: HasDirectionalCapability")] HRESULT HasDirectionalCapability([in]short nPort, [in]short nDevice, [in]short nSource, [out, retval]VARIANT_BOOL *pbCap);
        [id(12), helpstring("Method: HasArbitraryWaveformCapability")] HRESULT HasArbitraryWaveformCapability([in]short nPort, [in]short nDevice, [in]short nSource, [out, retval]VARIANT_BOOL *pbCap);
        [id(13), helpstring("Method: GetAutoStopTime")] HRESULT GetAutoStopTime([in]short nPort, [in]short nDevice, [in]short nSource, [out,retval]double *pfTime);
        [id(14), helpstring("Method: SetAutoStopTime")] HRESULT SetAutoStopTime([in]short nPort, [in]short nDevice, [in]short nSource, [in]double fTime, [out,retval]VARIANT_BOOL *pbResult);
        [id(15), helpstring("Method: Vibrate")] HRESULT Vibrate([in]short nPort, [in]short nDevice, [in]short nSource, [in]VARIANT_BOOL bContinuousVib, [in]BSTR bstrVibType, [in]short nInitialPower, [in]BSTR bstrDirection, [in]double fFrequency, [in]short nWavesPerStep, [out, retval]VARIANT_BOOL *pbResult);
    };

    [
        uuid(12137082-A1CB-11d3-B16A-0008C76BE5B9),
        helpstring("Vibration Control")
    ]
    coclass VibrationControl
    {
        [default] interface IVibrationControl;
    };
};
