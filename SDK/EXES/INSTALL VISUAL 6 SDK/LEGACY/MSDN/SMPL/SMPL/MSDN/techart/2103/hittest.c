#include <windows.h>
#include <stdlib.h>
#include <memory.h>
#include "w32pen.h"

/***********************************************************************

  FUNCTION   : HitTestLine

  PARAMETERS : POINT pt0 - endpoint for line segment
               POINT pt1 - endpoint for line segment
			   POINTS ptMouse - mouse coordinates of hit
			   int nWidth - width of pen

  PURPOSE    : test if mouse click occurred on line segment while 
               adjusting for the width of line

  CALLS      : GetDC
               ReleaseDC
			   SetGraphicsMode
			   SetWorldTransform

  MESSAGES   : none

  RETURNS    : BOOL - TRUE if the point was within the width of the 
                      pen about the line 
					  FALSE if the point lies outside of the width
					  of the pen about the line

  COMMENTS   : uses VECTOR2D.DLL

  HISTORY    : 9/20/93 - created - denniscr

************************************************************************/

BOOL HitTestLine(POINT pt0, POINT pt1, POINTS ptMouse, int nWidth)
{
  HDC hdc;
  POINT PtM;
  VECTOR2D tt0, tt1;
  double dist;
  int nHalfWidth;

  nHalfWidth = (nWidth/2 < 1) ? 1 : nWidth/2;
  //
  //convert the line into a vector
  //
  POINTS2VECTOR2D(pt0, pt1, tt0);
  //
  //convert the mouse points (short) into POINT (long)
  //
  MPOINT2POINT(ptMouse ,PtM);
  POINTS2VECTOR2D(pt0, PtM, tt1);
  //
  //if the mouse click is past the endpoints of 
  //a line segment return FALSE
  //
  if (pt0.x <= pt1.x)
  {
    if (PtM.x < pt0.x || PtM.x > pt1.x)
	  return (FALSE);
  }
  else
  {
    if (PtM.x > pt0.x || PtM.x < pt1.x)
	  return (FALSE);
  }
  //
  //currently, the only transform used is the identity
  //
  hdc = GetDC(hwndMain);
  SetGraphicsMode(hdc, GM_ADVANCED);

  if (SetWorldTransform(hdc, &pPenCurrent->xf))
  {
    //
	//this is the call to the function that does the work
	//of obtaining the distance of the point to the line
	//
	dist = vDistFromPointToLine(&pt0, &pt1, &PtM);
    SetGraphicsMode(hdc, GM_COMPATIBLE);
  }
  ReleaseDC(hwndMain, hdc);
  //
  //TRUE if the distance is within the width of the pen about the
  //line otherwise FALSE
  //
  return (dist >= -nHalfWidth && dist <= nHalfWidth);
}

/***********************************************************************

  FUNCTION   : HitTestCurve

  PARAMETERS : PPENRECORD ppPen, PVECTOR2D bezCurve, POINTS ptMouse

  PURPOSE    : test if mouse click occurred on line segment while 
               adjusting for the width of line

  CALLS      : 
			   SetGraphicsMode
			   SetWorldTransform

  MESSAGES   : none

  RETURNS    : BOOL - TRUE if the point was within the width of the 
                      pen about the line 
					  FALSE if the point lies outside of the width
					  of the pen about the line

  COMMENTS   :

  HISTORY    : 9/20/93 - created - denniscr

************************************************************************/

BOOL HitTestCurve(PPENRECORD ppPen, PVECTOR2D bezCurve, POINTS ptMouse)
{
  static VECTOR2D pointOnCurve;
  static VECTOR2D mousept;				
  VECTOR2D v;
  int nHalfWidth;
  double dist;
  POINT pt0, pt1;
  HDC hdc;
  //
  //half the width of the current pen
  //
  nHalfWidth = (ppPen->dwWidth/2 < 1) ? 1 : ppPen->dwWidth/2;

  mousept.x = (double)ptMouse.x;
  mousept.y = (double)ptMouse.y;
  //
  //find the nearest point on the curve, generated by the control
  //points in bezCurve, to the position of the mouse click
  //
  hdc = GetDC(hwndMain);
  SetGraphicsMode(hdc, GM_ADVANCED);

  if (SetWorldTransform(hdc, &pPenCurrent->xf))
  {
    pointOnCurve = NearestPointOnCurve(&mousept, bezCurve);
    //
    //convert the point on the line and the mouse pt to a vector
    //
    pt0.x = (int)pointOnCurve.x;
    pt0.y = (int)pointOnCurve.y;
    pt1.x = (int)ptMouse.x;
    pt1.y = (int)ptMouse.y;
    POINTS2VECTOR2D(pt0, pt1, v);
    //
    //obtain the length of the vector that is normal to the line segment
    //used to draw the bez curve at the nearest point on the curve. That length 
    //is the distance of the mouse click to the curve.
    //
    dist = vVectorMagnitude(&v);
    SetGraphicsMode(hdc, GM_COMPATIBLE);
  }
  ReleaseDC(hwndMain, hdc);
  //
  //return true if the mouse click was inside the width of the line
  //
  return(dist >= -nHalfWidth && dist <= nHalfWidth);
}

/***********************************************************************

  FUNCTION   : HitTest

  PARAMETERS : POINTS ptMouse - mouse coordinate for hit-testing

  PURPOSE    : traverse the linked list of PPENRECORDS and find the
          	   line that hit test against the mouse coordinates

  CALLS      : HitTestLine
               HitTestCurve

  MESSAGES   : none

  RETURNS    : PPENRECORD - the address of the node containing the 
               pen record that was hit. If no hit then return NULL

  COMMENTS   :

  HISTORY    : created - denniscr

************************************************************************/

PPENRECORD HitTest(POINTS ptMouse, PPENRECORD pPenRecHit)
{
  int i;
  int nPt;
  PPENRECORD pTempPR = NULL;
  static VECTOR2D bezCurve[4];
  HDC hdc;
  HRGN hRgn;
  HBRUSH hpen, holdpen;
  PPENRECORD pTempHit = NULL;
  //
  //initialize record in which hit pen attributes will be copied
  //
  memset(pPenRecHit, 0, sizeof(PENRECORD));
  //
  //if there are nodes in the list then look at each and determine if it
  //was hit. As the list is traversed (toward most current node) then the
  //contents of pPenRecHit will be updated. This is a bit brain dead as
  //any object hit will be copied to pPenRecHit.
  //
  if (pPenList)
  {
    pTempPR = pPenList;
    do
 	{
 	    switch(pTempPR->dwLineType)
		{
		  case LT_POLYLINE:
		    //
			//hit-test lines using n as the left endpoint
			//and n+1 as the right endpoint
			//
            for (nPt = 0; nPt < 9; nPt++)
            {
               if (HitTestLine(pTempPR->PtsToDraw[nPt], 
                      pTempPR->PtsToDraw[nPt + 1], 
                      ptMouse, pTempPR->dwWidth))
		       {
			       //
				   //the line was hit so copy the penrecord into the
				   //hit record (both are of type PENRECORD)
				   //
				   memcpy(pPenRecHit, pTempPR, sizeof(PENRECORD));
				   pTempHit = pTempPR;
			   }
	        }
		    break;
	      case LT_ARC:
		  {
		      //
			  //draw the arc into a path then flatten the path and hit-test the 
			  //line segments returned by GetPath
			  //
			  int nNumPoints;
			  LPPOINT lpPt;
			  LPBYTE  lpB;
			  HPEN holdpen, hpen;

   		      hdc = GetDC(hwndMain);
			  if (BeginPath(hdc))
			  {
			    Arc(hdc, grWorkRect.left, grWorkRect.top, grWorkRect.right, grWorkRect.bottom, 
			        pTempPR->PtsToDraw[4].x, pTempPR->PtsToDraw[4].y, 
			        pTempPR->PtsToDraw[9].x, pTempPR->PtsToDraw[9].y);
				
			    if (EndPath(hdc))
			    {
			      if (FlattenPath(hdc))
			        nNumPoints = GetPath(hdc, (LPPOINT)NULL, (LPBYTE)NULL, 0);
				  if (nNumPoints > 0)
				  {
					lpPt = (LPPOINT)malloc((DWORD)(sizeof(POINT) * nNumPoints));
					lpB  = (LPBYTE)malloc((DWORD)(sizeof(BYTE) * nNumPoints));
			        nNumPoints = GetPath(hdc, lpPt, lpB, nNumPoints);

	                for (nPt = 0; nPt < nNumPoints - 1; nPt++)
	                {
		              if (HitTestLine(lpPt[nPt], lpPt[nPt + 1],
	                        ptMouse, pTempPR->dwWidth))
				      {
			             //
				         //the line was hit so copy the penrecord into the
				         //hit record (both are of type PENRECORD)
				         //
				         memcpy(pPenRecHit, pTempPR, sizeof(PENRECORD));
				         pTempHit = pTempPR;
				      }
					}
				    free(lpPt);
				    free(lpB);
				  }
			    }
			  }
			  ReleaseDC(hwndMain, hdc);
			}
		    break;
		  case LT_BEZIER:
		  {
			int nNumPoints;
			LPPOINT lpPt;
			LPBYTE  lpB;
			HPEN holdpen, hpen;
			if (bUsePaths)
			{
   		      hdc = GetDC(hwndMain);
			  if (BeginPath(hdc))
			  {
		        PolyBezier(hdc, (LPPOINT)pTempPR->PtsToDraw, NUMPOINTS);
			    if (EndPath(hdc))
			    {
			      if (FlattenPath(hdc))
			        nNumPoints = GetPath(hdc, (LPPOINT)NULL, (LPBYTE)NULL, 0);
				  if (nNumPoints > 0)
				  {
					lpPt = (LPPOINT)malloc((DWORD)(sizeof(POINT) * nNumPoints));
					lpB  = (LPBYTE)malloc((DWORD)(sizeof(BYTE) * nNumPoints));
			        nNumPoints = GetPath(hdc, lpPt, lpB, nNumPoints);

	                for (nPt = 0; nPt < nNumPoints - 1; nPt++)
	                {
                      if (HitTestLine(lpPt[nPt], lpPt[nPt + 1],
	                        ptMouse, pTempPR->dwWidth))
				      {
				         memcpy(pPenRecHit, pTempPR, sizeof(PENRECORD));
				         pTempHit = pTempPR;
				      }
			        }
					free(lpPt);
					free(lpB);
				  }
			    }
			  }
			  ReleaseDC(hwndMain, hdc);
			}
			else
			{
              //
              //the array of points contained in ppPen (PENRECORD) contains
              //10 points. The first 4 are the control points for the first 
              //bezier curve. The 4th - 7th points are for the second curve
              //and the 7th - 10th are for the third and final curve.
              //
              for (nPt = 0; nPt < NUMPOINTS - 3; nPt += 3)
              {
	            //
	            //load bezCurve with the control points for a bezier curve
	            //
	            for (i = 0; i < 4; i++)
	            {
                  bezCurve[i].x = (double)pTempPR->PtsToDraw[nPt + i].x;
                  bezCurve[i].y = (double)pTempPR->PtsToDraw[nPt + i].y;
	            }

		        if (HitTestCurve(pTempPR, (PVECTOR2D)&bezCurve, ptMouse))
			    {
	 	          memcpy(pPenRecHit, pTempPR, sizeof(PENRECORD));
		          pTempHit = pTempPR;
				  break;
			    }
			  }
		    }
		  }
  		  break;

		  default:
		    break;
		}
	    pTempPR = pTempPR->next;
	}
  	while (pTempPR != pPenList); 

  }
  return(pTempHit);
}
