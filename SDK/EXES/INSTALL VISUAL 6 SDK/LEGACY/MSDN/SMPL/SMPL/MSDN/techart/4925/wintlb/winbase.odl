
#ifdef WIN32
[
uuid(54674048-3A82-101B-8181-00AA003743D3),
helpstring("Win32 Base Functions"),
dllname("KERNEL32.DLL")
]
module WinBase {


    [
    usesgetlasterror,
    entry("SearchPathA"),
    helpstring("Searches lpPath for lpFileName with lpfExtension and returns full path result in lpBuffer and lpFilePart"),
    ]
    DWORD WINAPI SearchPath([in] LPCSTR lpPath, [in] LPCSTR lpFileName,
                            [in] LPCSTR lpExtension,
                            [in] DWORD nBufferLength,
                            [in, out] LPSTR lpBuffer,
                            [in, out] DWORD FAR *lpFilePart);

    [
    usesgetlasterror,
    entry("GetFullPathNameA"),
    helpstring("Returns full path of lpFileName in lpBuffer and lpFilePart"),
    ]
    DWORD WINAPI GetFullPathName([in] LPCSTR lpFileName,
                                 [in] DWORD nBufferLength,
                                 [in, out] LPSTR lpBuffer,
                                 [in, out] DWORD FAR *lpFilePart);

    [
    usesgetlasterror,
    entry("GetDiskFreeSpaceA"),
    helpstring("Returns information about disk lpRootPathName in lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters"),
    ]
    BOOL WINAPI GetDiskFreeSpace([in] LPCSTR lpRootPathName,
                                 [in, out] DWORD FAR *lpSectorsPerCluster,
                                 [in, out] DWORD FAR *lpBytesPerSector,
                                 [in, out] DWORD FAR *lpNumberOfFreeClusters,
                                 [in, out] DWORD FAR *lpTotalNumberOfClusters);

    [
    usesgetlasterror,
    entry("GetDriveTypeA"),
    helpstring("Returns the type of disk lpRootPathName"),
    ]
    UINT WINAPI GetDriveType([in]LPCSTR lpRootPathName);

    [
    usesgetlasterror,
    entry("GetTempPathA"),
    helpstring("Returns the directory for temporary files in lpBuffer"),
    ]
    DWORD WINAPI GetTempPath([in] DWORD nBufferLength,
                             [in,out] LPSTR lpBuffer);

    [
    usesgetlasterror,
    entry("GetTempFileNameA"),
    helpstring("Returns name of a unique file with lpPrefixString for directory lpPathName in lpTempfileName"),
    ]
    UINT WINAPI GetTempFileName([in] LPCSTR lpPathName,
                                [in] LPCSTR lpPrefixString,
                                [in] UINT uUnique,
                                [in, out] LPSTR lpTempFileName);

    [
    usesgetlasterror,
    entry("GetLogicalDriveStringsA"),
    helpstring("Returns root path strings (with terminating double null) for all valid drives in lpBuffer"),
    ]
    DWORD WINAPI GetLogicalDriveStrings([in] DWORD nBufferLength,
                                        [in, out] LPSTR lpBuffer);

    [
    usesgetlasterror,
    entry("GetLogicalDrives"),
    helpstring("Returns valid lettered drives in bit field (A in bit 0)"),
    ]
    DWORD WINAPI GetLogicalDrives(VOID);

    [
    usesgetlasterror,
    entry("GetEnvironmentStrings"),
    helpstring("Returns pointer to environment variable strings (with terminating double null)"),
    ]
    DWORD WINAPI GetEnvironmentStrings(VOID);

    [
    usesgetlasterror,
    entry("GetEnvironmentVariableA"),
    helpstring("Returns contents of environment variable lpName in lpBuffer"),
    ]
    DWORD WINAPI GetEnvironmentVariable([in] LPCSTR lpName,
                                        [in, out] LPSTR lpBuffer,
                                        [in] DWORD nSize
                                        );

    [
    usesgetlasterror,
    entry("SetEnvironmentVariableA"),
    helpstring("Sets environment variable lpName to value lpValue (deletes variable if lpValue is Null)"),
    ]
    BOOL WINAPI SetEnvironmentVariable([in] LPCSTR lpName,
                                       [in] LPCSTR lpValue);

    [
    usesgetlasterror,
    entry("SetEnvironmentVariableA"),
    helpstring("Sets environment variable lpName to value lpValue (deletes variable if lpValue is Null)"),
    ]
    BOOL WINAPI SetEnvVariable([in] LPCSTR lpName,
                               [in] LPCSTR lpValue);
    [
    usesgetlasterror,
    entry("GetLastError"),
    helpstring("Returns the number of the last error to occur"),
    ]
    DWORD WINAPI GetLastError(VOID);

    [
    usesgetlasterror,
    entry("SetLastError"),
    helpstring("Sets the last error number to dwErrCode"),
    ]
    VOID WINAPI SetLastError([in] DWORD dwErrCode);

    [
    usesgetlasterror,
    entry("GetComputerNameA"),
    helpstring("Gets the computer (machine) name"),
    ]
    BOOL WINAPI GetComputerName([in, out] LPSTR lpBuffer,
                                [in, out] DWORD FAR * nSize);

    [
    usesgetlasterror,
    entry("SetComputerNameA"),
    helpstring("Sets the computer (machine) name"),
    ]
    BOOL WINAPI SetComputerName([in] LPCSTR lpComputerName);

    [
    usesgetlasterror,
    entry("GetVolumeInformationA"),
    helpstring("Gets information about a disk including volume name, serial number, maximum component length, and file system name"),
    ]
    BOOL WINAPI GetVolumeInformation([in] LPCSTR lpRootPathName,
                                     [in, out] LPSTR lpVolumeNameBuffer,
                                     [in] DWORD nVolumeNameSize,
                                     [in, out] DWORD FAR *lpVolumeSerialNumber,
                                     [in, out] DWORD FAR *lpMaximumComponentLength,
                                     [in, out] DWORD FAR *lpFileSystemFlags,
                                     [in, out] LPSTR lpFileSystemNameBuffer,
                                     [in] DWORD nFileSystemNameSize);

    [
    entry("FlushFileBuffers"),
    helpstring("Writes file buffers for an open handle to disk"),
    ]
    BOOL WINAPI FlushFileBuffers([in] HANDLE hFile);

    [
    entry("Beep"),
    helpstring("Plays a sound of given frequency and duration"),
    ]
    BOOL WINAPI Beep([in] DWORD dwFreq, [in] DWORD dwDuration);

    /* To be implemented
    BOOL WINAPI FreeEnvironmentStringsA(
        LPSTR
        );

    DWORD WINAPI ExpandEnvironmentStringsA(
        LPCSTR lpSrc,
        LPSTR lpDst,
        DWORD nSize
        );

    */

    [
    entry("SetVolumeLabelA"),
    helpstring("Sets label of file system volume specified by root path"),
    ]
    BOOL WINAPI SetVolumeLabel([in] LPCSTR lpRootPathName,
                               [in] LPCSTR lpVolumeName);

    [
    entry("Sleep"),
    helpstring("Suspends execution of the current thread for a specified interval"),
    ]
    VOID WINAPI Sleep([in] DWORD dwMilliseconds);


    /* Find file not implemented
    HANDLE WINAPI FindFirstFileA(
        LPCSTR lpFileName,
        LPWIN32_FIND_DATAA lpFindFileData
        );

    BOOL WINAPI FindNextFileA(
        HANDLE hFindFile,
        LPWIN32_FIND_DATAA lpFindFileData
        );

    BOOL WINAPI FindClose(HANDLE hFindFile);

    typedef struct _WIN32_FIND_DATAA {
        DWORD dwFileAttributes;
        FILETIME ftCreationTime;
        FILETIME ftLastAccessTime;
        FILETIME ftLastWriteTime;
        DWORD nFileSizeHigh;
        DWORD nFileSizeLow;
        DWORD dwReserved0;
        DWORD dwReserved1;
        CHAR   cFileName[ MAX_PATH ];
        CHAR   cAlternateFileName[ 14 ];
    } WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
    */

    /* Interlocked not implemented
    LONG WINAPI InterlockedIncrement(
        LPLONG lpAddend
        );

    LONG WINAPI InterlockedDecrement(
        LPLONG lpAddend
        );

    LONG WINAPI InterlockedExchange(
        LPLONG Target,
        LONG Value
        );
    */

    /* Can't implement GlobalMemoryStatus
    VOID WINAPI GlobalMemoryStatus(
        LPMEMORYSTATUS lpBuffer
        );
    */

    /* Instruction cache not implemented
    BOOL WINAPI FlushInstructionCache(
        HANDLE hProcess,
        LPCVOID lpBaseAddress,
        DWORD dwSize
        );
    */

    /*
    typedef LONG (WINAPI *PTOP_LEVEL_EXCEPTION_FILTER)(
        struct _EXCEPTION_POINTERS *ExceptionInfo
        );
    typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;
    */

    /* Threads not implemented
    HANDLE WINAPI CreateThread(
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        DWORD dwStackSize,
        LPTHREAD_START_ROUTINE lpStartAddress,
        LPVOID lpParameter,
        DWORD dwCreationFlags,
        LPDWORD lpThreadId
        );

    HANDLE WINAPI CreateRemoteThread(
        HANDLE hProcess,
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        DWORD dwStackSize,
        LPTHREAD_START_ROUTINE lpStartAddress,
        LPVOID lpParameter,
        DWORD dwCreationFlags,
        LPDWORD lpThreadId
        );

    HANDLE WINAPI GetCurrentThread(
        VOID
        );

    DWORD WINAPI GetCurrentThreadId(
        VOID
        );

    DWORD WINAPI SetThreadAffinityMask(
        HANDLE hThread,
        DWORD dwThreadAffinityMask
        );

    BOOL WINAPI SetThreadPriority(
        HANDLE hThread,
        int nPriority
        );

    int WINAPI GetThreadPriority(
        HANDLE hThread
        );

    BOOL WINAPI GetThreadTimes(
        HANDLE hThread,
        LPFILETIME lpCreationTime,
        LPFILETIME lpExitTime,
        LPFILETIME lpKernelTime,
        LPFILETIME lpUserTime
        );

    VOID WINAPI ExitThread(
        DWORD dwExitCode
        );

    BOOL WINAPI TerminateThread(
        HANDLE hThread,
        DWORD dwExitCode
        );

    BOOL WINAPI GetExitCodeThread(
        HANDLE hThread,
        LPDWORD lpExitCode
        );

    BOOL WINAPI GetThreadSelectorEntry(
        HANDLE hThread,
        DWORD dwSelector,
        LPLDT_ENTRY lpSelectorEntry
        );
    */

    /* Completion not implemented
    BOOL WINAPI GetOverlappedResult(
        HANDLE hFile,
        LPOVERLAPPED lpOverlapped,
        LPDWORD lpNumberOfBytesTransferred,
        BOOL bWait
        );

    HANDLE WINAPI CreateIoCompletionPort(
        HANDLE FileHandle,
        HANDLE ExistingCompletionPort,
        DWORD CompletionKey,
        DWORD NumberOfConcurrentThreads
        );

    BOOL WINAPI GetQueuedCompletionStatus(
        HANDLE CompletionPort,
        LPDWORD lpNumberOfBytesTransferred,
        LPDWORD lpCompletionKey,
        LPOVERLAPPED *lpOverlapped,
        DWORD dwMilliseconds
        );
    */

    /* Debugger support not implemented
    BOOL WINAPI ReadProcessMemory(
        HANDLE hProcess,
        LPCVOID lpBaseAddress,
        LPVOID lpBuffer,
        DWORD nSize,
        LPDWORD lpNumberOfBytesRead
        );

    BOOL WINAPI WriteProcessMemory(
        HANDLE hProcess,
        LPVOID lpBaseAddress,
        LPVOID lpBuffer,
        DWORD nSize,
        LPDWORD lpNumberOfBytesWritten
        );

    BOOL WINAPI GetThreadContext(
        HANDLE hThread,
        LPCONTEXT lpContext
        );

    BOOL WINAPI SetThreadContext(
        HANDLE hThread,
        CONST CONTEXT *lpContext
        );

    DWORD WINAPI SuspendThread(
        HANDLE hThread
        );

    DWORD WINAPI ResumeThread(
        HANDLE hThread
        );

    BOOL WINAPI WaitForDebugEvent(
        LPDEBUG_EVENT lpDebugEvent,
        DWORD dwMilliseconds
        );

    BOOL WINAPI ContinueDebugEvent(
        DWORD dwProcessId,
        DWORD dwThreadId,
        DWORD dwContinueStatus
        );

    BOOL WINAPI DebugActiveProcess(
        DWORD dwProcessId
        );
    */

    /* Critical sections not implemented
    VOID WINAPI InitializeCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection
        );

    VOID WINAPI EnterCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection
        );

    VOID WINAPI LeaveCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection
        );

    VOID WINAPI DeleteCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection
        );
    */

    /* Interprocess communication not implemented
    BOOL WINAPI SetEvent(
        HANDLE hEvent
        );

    BOOL WINAPI ResetEvent(
        HANDLE hEvent
        );

    BOOL WINAPI PulseEvent(
        HANDLE hEvent
        );

    BOOL WINAPI ReleaseSemaphore(
        HANDLE hSemaphore,
        LONG lReleaseCount,
        LPLONG lpPreviousCount
        );

    BOOL WINAPI ReleaseMutex(
        HANDLE hMutex
        );
    */

    [
    usesgetlasterror,
    entry("WaitForSingleObject"),
    helpstring("Waits until the specified object reaches the signaled state, or until the time-out elapses"),
    ]
    DWORD WINAPI WaitForSingleObject(
        [in] HANDLE hHandle,
        [in] DWORD dwMilliseconds
        );

    [
    usesgetlasterror,
    entry("WaitForMultipleObjects"),
    helpstring("Waits until any one or all of the specified objects reaches the signaled state, or until the time-out elapses"),
    ]
    DWORD WINAPI WaitForMultipleObjects(
        [in] DWORD nCount,
        [in, out] HANDLE *lpHandles,
        [in] BOOL bWaitAll,
        [in] DWORD dwMilliseconds
        );

    /*
    typedef
    VOID
    (WINAPI *LPOVERLAPPED_COMPLETION_ROUTINE)(
        DWORD dwErrorCode,
        DWORD dwNumberOfBytesTransfered,
        LPOVERLAPPED lpOverlapped
        );

    DWORD WINAPI SleepEx(
        DWORD dwMilliseconds,
        BOOL bAlertable
        );

    DWORD WINAPI WaitForSingleObjectEx(
        HANDLE hHandle,
        DWORD dwMilliseconds,
        BOOL bAlertable
        );

    DWORD WINAPI WaitForMultipleObjectsEx(
        DWORD nCount,
        CONST HANDLE *lpHandles,
        BOOL bWaitAll,
        DWORD dwMilliseconds,
        BOOL bAlertable
        );

    HANDLE WINAPI CreateMutexA(
        LPSECURITY_ATTRIBUTES lpMutexAttributes,
        BOOL bInitialOwner,
        LPCSTR lpName
        );

    HANDLE WINAPI OpenMutexA(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCSTR lpName
        );

    HANDLE WINAPI CreateEventA(
        LPSECURITY_ATTRIBUTES lpEventAttributes,
        BOOL bManualReset,
        BOOL bInitialState,
        LPCSTR lpName
        );

    HANDLE WINAPI OpenEventA(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCSTR lpName
        );

    HANDLE WINAPI CreateSemaphoreA(
        LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
        LONG lInitialCount,
        LONG lMaximumCount,
        LPCSTR lpName
        );

    HANDLE WINAPI OpenSemaphoreA(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCSTR lpName
        );

    */

    /* Tape and backup not implemented
    DWORD WINAPI SetTapePosition(
        HANDLE hDevice,
        DWORD dwPositionMethod,
        DWORD dwPartition,
        DWORD dwOffsetLow,
        DWORD dwOffsetHigh,
        BOOL bImmediate
        );

    DWORD WINAPI GetTapePosition(
        HANDLE hDevice,
        DWORD dwPositionType,
        LPDWORD lpdwPartition,
        LPDWORD lpdwOffsetLow,
        LPDWORD lpdwOffsetHigh
        );

    DWORD WINAPI PrepareTape(
        HANDLE hDevice,
        DWORD dwOperation,
        BOOL bImmediate
        );

    DWORD WINAPI EraseTape(
        HANDLE hDevice,
        DWORD dwEraseType,
        BOOL bImmediate
        );

    DWORD WINAPI CreateTapePartition(
        HANDLE hDevice,
        DWORD dwPartitionMethod,
        DWORD dwCount,
        DWORD dwSize
        );

    DWORD WINAPI WriteTapemark(
        HANDLE hDevice,
        DWORD dwTapemarkType,
        DWORD dwTapemarkCount,
        BOOL bImmediate
        );

    DWORD WINAPI GetTapeStatus(
        HANDLE hDevice
        );

    DWORD WINAPI GetTapeParameters(
        HANDLE hDevice,
        DWORD dwOperation,
        LPDWORD lpdwSize,
        LPVOID lpTapeInformation
        );

    //const int GET_TAPE_MEDIA_INFORMATION = 0;
    //const int GET_TAPE_DRIVE_INFORMATION = 1;

    DWORD WINAPI SetTapeParameters(
        HANDLE hDevice,
        DWORD dwOperation,
        LPVOID lpTapeInformation
        );

    //const int SET_TAPE_MEDIA_INFORMATION = 0;
    //const int SET_TAPE_DRIVE_INFORMATION = 1;

    BOOL WINAPI BackupRead(
        HANDLE hFile,
        LPBYTE lpBuffer,
        DWORD nNumberOfBytesToRead,
        LPDWORD lpNumberOfBytesRead,
        BOOL bAbort,
        BOOL bProcessSecurity,
        LPVOID *lpContext
        );

    BOOL WINAPI BackupSeek(
        HANDLE hFile,
        DWORD  dwLowBytesToSeek,
        DWORD  dwHighBytesToSeek,
        LPDWORD lpdwLowByteSeeked,
        LPDWORD lpdwHighByteSeeked,
        LPVOID *lpContext
        );

    BOOL WINAPI BackupWrite(
        HANDLE hFile,
        LPBYTE lpBuffer,
        DWORD nNumberOfBytesToWrite,
        LPDWORD lpNumberOfBytesWritten,
        BOOL bAbort,
        BOOL bProcessSecurity,
        LPVOID *lpContext
        );

    typedef struct _WIN32_STREAM_ID {
            DWORD          dwStreamId ;
            DWORD          dwStreamAttributes ;
            LARGE_INTEGER  Size ;
            DWORD          dwStreamNameSize ;
            WCHAR          cStreamName[ ANYSIZE_ARRAY ] ;
    } WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;

    //  Stream Ids

    const DWORD BACKUP_INVALID         = 0x00000000;
    const DWORD BACKUP_DATA            = 0x00000001;
    const DWORD BACKUP_EA_DATA         = 0x00000002;
    const DWORD BACKUP_SECURITY_DATA   = 0x00000003;
    const DWORD BACKUP_ALTERNATE_DATA  = 0x00000004;
    const DWORD BACKUP_LINK            = 0x00000005;
    const DWORD BACKUP_PROPERTY_DATA   = 0x00000006;

    //  Stream Attributes

    const DWORD STREAM_NORMAL_ATTRIBUTE    = 0x00000000;
    const DWORD STREAM_MODIFIED_WHEN_READ  = 0x00000001;
    const DWORD STREAM_CONTAINS_SECURITY   = 0x00000002;
    const DWORD STREAM_CONTAINS_PROPERTIES = 0x00000004;

    */

    /* Time not implemented
    VOID WINAPI GetSystemTime(
        LPSYSTEMTIME lpSystemTime
        );

    BOOL WINAPI SetSystemTime(
        CONST SYSTEMTIME *lpSystemTime
        );

    VOID WINAPI GetLocalTime(
        LPSYSTEMTIME lpSystemTime
        );

    BOOL WINAPI SetLocalTime(
        CONST SYSTEMTIME *lpSystemTime
        );

    typedef struct _TIME_ZONE_INFORMATION {
        LONG Bias;
        WCHAR StandardName[ 32 ];
        SYSTEMTIME StandardDate;
        LONG StandardBias;
        WCHAR DaylightName[ 32 ];
        SYSTEMTIME DaylightDate;
        LONG DaylightBias;
    } TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

    BOOL WINAPI SystemTimeToTzSpecificLocalTime(
        LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
        LPSYSTEMTIME lpUniversalTime,
        LPSYSTEMTIME lpLocalTime
        );

    DWORD WINAPI GetTimeZoneInformation(
        LPTIME_ZONE_INFORMATION lpTimeZoneInformation
        );

    BOOL WINAPI SetTimeZoneInformation(
        CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
        );

    //
    // Routines to convert back and forth between system time and file time
    //

    BOOL WINAPI SystemTimeToFileTime(
        CONST SYSTEMTIME *lpSystemTime,
        LPFILETIME lpFileTime
        );

    BOOL WINAPI FileTimeToLocalFileTime(
        CONST FILETIME *lpFileTime,
        LPFILETIME lpLocalFileTime
        );

    BOOL WINAPI LocalFileTimeToFileTime(
        CONST FILETIME *lpLocalFileTime,
        LPFILETIME lpFileTime
        );

    BOOL WINAPI FileTimeToSystemTime(
        CONST FILETIME *lpFileTime,
        LPSYSTEMTIME lpSystemTime
        );

    LONG WINAPI CompareFileTime(
        CONST FILETIME *lpFileTime1,
        CONST FILETIME *lpFileTime2
        );

    BOOL WINAPI FileTimeToDosDateTime(
        CONST FILETIME *lpFileTime,
        LPWORD lpFatDate,
        LPWORD lpFatTime
        );

    BOOL WINAPI DosDateTimeToFileTime(
        WORD wFatDate,
        WORD wFatTime,
        LPFILETIME lpFileTime
        );

    BOOL WINAPI SetSystemTimeAdjustment(
        DWORD dwTimeAdjustment,
        BOOL  bTimeAdjustmentDisabled
        );

    BOOL WINAPI GetSystemTimeAdjustment(
        PDWORD lpTimeAdjustment,
        PDWORD lpTimeIncrement,
        PBOOL  lpTimeAdjustmentDisabled
        );
    */

    /* GetSystemInfo can't be implemented
    VOID WINAPI GetSystemInfo(
        LPSYSTEM_INFO lpSystemInfo
        );
    */

    /* Format message not implemented
    DWORD WINAPI FormatMessageA(
        DWORD dwFlags,
        LPCVOID lpSource,
        DWORD dwMessageId,
        DWORD dwLanguageId,
        LPSTR lpBuffer,
        DWORD nSize,
        va_list *Arguments
        );

    const DWORD FORMAT_MESSAGE_ALLOCATE_BUFFER  = 0x00000100;
    const DWORD FORMAT_MESSAGE_IGNORE_INSERTS   = 0x00000200;
    const DWORD FORMAT_MESSAGE_FROM_STRING      = 0x00000400;
    const DWORD FORMAT_MESSAGE_FROM_HMODULE     = 0x00000800;
    const DWORD FORMAT_MESSAGE_FROM_SYSTEM      = 0x00001000;
    const DWORD FORMAT_MESSAGE_ARGUMENT_ARRAY   = 0x00002000;
    const DWORD FORMAT_MESSAGE_MAX_WIDTH_MASK   = 0x000000FF;
    */

    /* Pipes not implemented
    HANDLE WINAPI CreateNamedPipeA(
        LPCSTR lpName,
        DWORD dwOpenMode,
        DWORD dwPipeMode,
        DWORD nMaxInstances,
        DWORD nOutBufferSize,
        DWORD nInBufferSize,
        DWORD nDefaultTimeOut,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes
        );

    BOOL WINAPI GetNamedPipeHandleStateA(
        HANDLE hNamedPipe,
        LPDWORD lpState,
        LPDWORD lpCurInstances,
        LPDWORD lpMaxCollectionCount,
        LPDWORD lpCollectDataTimeout,
        LPSTR lpUserName,
        DWORD nMaxUserNameSize
        );

    BOOL WINAPI CallNamedPipeA(
        LPCSTR lpNamedPipeName,
        LPVOID lpInBuffer,
        DWORD nInBufferSize,
        LPVOID lpOutBuffer,
        DWORD nOutBufferSize,
        LPDWORD lpBytesRead,
        DWORD nTimeOut
        );

    BOOL WINAPI WaitNamedPipeA(
        LPCSTR lpNamedPipeName,
        DWORD nTimeOut
        );

    BOOL WINAPI CreatePipe(
        PHANDLE hReadPipe,
        PHANDLE hWritePipe,
        LPSECURITY_ATTRIBUTES lpPipeAttributes,
        DWORD nSize
        );

    BOOL WINAPI ConnectNamedPipe(
        HANDLE hNamedPipe,
        LPOVERLAPPED lpOverlapped
        );

    BOOL WINAPI DisconnectNamedPipe(
        HANDLE hNamedPipe
        );

    BOOL WINAPI SetNamedPipeHandleState(
        HANDLE hNamedPipe,
        LPDWORD lpMode,
        LPDWORD lpMaxCollectionCount,
        LPDWORD lpCollectDataTimeout
        );

    BOOL WINAPI GetNamedPipeInfo(
        HANDLE hNamedPipe,
        LPDWORD lpFlags,
        LPDWORD lpOutBufferSize,
        LPDWORD lpInBufferSize,
        LPDWORD lpMaxInstances
        );

    BOOL WINAPI PeekNamedPipe(
        HANDLE hNamedPipe,
        LPVOID lpBuffer,
        DWORD nBufferSize,
        LPDWORD lpBytesRead,
        LPDWORD lpTotalBytesAvail,
        LPDWORD lpBytesLeftThisMessage
        );

    BOOL WINAPI TransactNamedPipe(
        HANDLE hNamedPipe,
        LPVOID lpInBuffer,
        DWORD nInBufferSize,
        LPVOID lpOutBuffer,
        DWORD nOutBufferSize,
        LPDWORD lpBytesRead,
        LPOVERLAPPED lpOverlapped
        );
    */

    /* Mail slots not implemented
    HANDLE WINAPI CreateMailslotA(
        LPCSTR lpName,
        DWORD nMaxMessageSize,
        DWORD lReadTimeout,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes
        );

    BOOL WINAPI GetMailslotInfo(
        HANDLE hMailslot,
        LPDWORD lpMaxMessageSize,
        LPDWORD lpNextSize,
        LPDWORD lpMessageCount,
        LPDWORD lpReadTimeout
        );

    BOOL WINAPI SetMailslotInfo(
        HANDLE hMailslot,
        DWORD lReadTimeout
        );
    */

    [
    usesgetlasterror,
    entry("MapViewOfFile"),
    helpstring("Opens view of specified file mapping"),
    ]
    LPVOID WINAPI MapViewOfFile(
        [in] HANDLE hFileMappingObject,
        [in] DWORD dwDesiredAccess,
        [in] DWORD dwFileOffsetHigh,
        [in] DWORD dwFileOffsetLow,
        [in] DWORD dwNumberOfBytesToMap
        );

    [
    usesgetlasterror,
    entry("MapViewOfFileEx"),
    helpstring("Opens view of specified file mapping at suggested address"),
    ]
    LPVOID WINAPI MapViewOfFileEx(
        [in] HANDLE hFileMappingObject,
        [in] DWORD dwDesiredAccess,
        [in] DWORD dwFileOffsetHigh,
        [in] DWORD dwFileOffsetLow,
        [in] DWORD dwNumberOfBytesToMap,
        [in] LPVOID lpBaseAddress
        );

    [
    usesgetlasterror,
    entry("FlushViewOfFile"),
    helpstring("Writes file mapping to disk"),
    ]
    BOOL WINAPI FlushViewOfFile(
        [in] LPCVOID lpBaseAddress,
        [in] DWORD dwNumberOfBytesToFlush
        );

    [
    usesgetlasterror,
    entry("UnmapViewOfFile"),
    helpstring("Releases file mapping"),
    ]
    BOOL WINAPI UnmapViewOfFile(
        [in] LPVOID lpBaseAddress
        );

    [
    usesgetlasterror,
    entry("CreateFileMappingA"),
    helpstring("Maps file to memory or creates shared memory (if hFile is -1), assigns lpName to mapping, and returns mapping handle"),
    ]
    HANDLE WINAPI CreateFileMapping(
        [in] HANDLE hFile,
        [in] DWORD lpFileMappingAttributes,
        [in] DWORD flProtect,
        [in] DWORD dwMaximumSizeHigh,
        [in] DWORD dwMaximumSizeLow,
        [in] LPCSTR lpName
        );

    [
    usesgetlasterror,
    entry("OpenFileMappingA"),
    helpstring("Opens existing mapping specified by lpName"),
    ]
    HANDLE WINAPI OpenFileMapping(
        [in] DWORD dwDesiredAccess,
        [in] BOOL bInheritHandle,
        [in] LPCSTR lpName
        );

    /*
    BOOL WINAPI IsTextUnicode(
        CONST LPVOID lpBuffer,
        int cb,
        LPINT lpi
        );
    */

    /* TLS Not Implemented
    DWORD WINAPI TlsAlloc(
        VOID
        );

    //define TLS_OUT_OF_INDEXES (DWORD)0xFFFFFFFF

    LPVOID WINAPI TlsGetValue(
        DWORD dwTlsIndex
        );

    BOOL WINAPI TlsSetValue(
        DWORD dwTlsIndex,
        LPVOID lpTlsValue
        );

    BOOL WINAPI TlsFree(
        DWORD dwTlsIndex
        );

    const DWORD SHUTDOWN_NORETRY               = 0x00000001;
    */


    /* Some directory not implemented
    BOOL WINAPI SetCurrentDirectoryA(
        LPCSTR lpPathName
        );

    DWORD WINAPI GetCurrentDirectoryA(
        DWORD nBufferLength,
        LPSTR lpBuffer
        );

    BOOL WINAPI CreateDirectoryA(
        LPCSTR lpPathName,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes
        );

    BOOL WINAPI CreateDirectoryExA(
        LPCSTR lpTemplateDirectory,
        LPCSTR lpNewDirectory,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes
        );

    BOOL WINAPI RemoveDirectoryA(
        LPCSTR lpPathName
        );

    const DWORD DDD_RAW_TARGET_PATH        = 0x00000001;
    const DWORD DDD_REMOVE_DEFINITION      = 0x00000002;
    const DWORD DDD_EXACT_MATCH_ON_REMOVE  = 0x00000004;


    BOOL WINAPI DefineDosDeviceA(
        DWORD dwFlags,
        LPCSTR lpDeviceName,
        LPCSTR lpTargetPath
        );

    DWORD WINAPI QueryDosDeviceA(
        LPCSTR lpDeviceName,
        LPSTR lpTargetPath,
        DWORD ucchMax
        );

    */

    /* Event logging not implemented
    BOOL WINAPI ClearEventLogA (
        HANDLE hEventLog,
        LPCSTR lpBackupFileName
        );

    BOOL WINAPI BackupEventLogA (
        HANDLE hEventLog,
        LPCSTR lpBackupFileName
        );

    BOOL WINAPI CloseEventLog (
        HANDLE hEventLog
        );

    BOOL WINAPI DeregisterEventSource (
        HANDLE hEventLog
        );

    BOOL WINAPI NotifyChangeEventLog (
        HANDLE hEventLog,
        HANDLE hEvent
        );

    BOOL WINAPI GetNumberOfEventLogRecords (
        HANDLE hEventLog,
        PDWORD NumberOfRecords
        );

    BOOL WINAPI GetOldestEventLogRecord (
        HANDLE hEventLog,
        PDWORD OldestRecord
        );

    HANDLE WINAPI OpenEventLogA (
        LPCSTR lpUNCServerName,
        LPCSTR lpSourceName
        );

    HANDLE WINAPI RegisterEventSourceA (
        LPCSTR lpUNCServerName,
        LPCSTR lpSourceName
        );

    HANDLE WINAPI OpenBackupEventLogA (
        LPCSTR lpUNCServerName,
        LPCSTR lpFileName
        );

    BOOL WINAPI ReadEventLogA (
         HANDLE     hEventLog,
         DWORD      dwReadFlags,
         DWORD      dwRecordOffset,
         LPVOID     lpBuffer,
         DWORD      nNumberOfBytesToRead,
         DWORD      *pnBytesRead,
         DWORD      *pnMinNumberOfBytesNeeded
        );

    BOOL WINAPI ReportEventA (
         HANDLE     hEventLog,
         WORD       wType,
         WORD       wCategory,
         DWORD      dwEventID,
         PSID       lpUserSid,
         WORD       wNumStrings,
         DWORD      dwDataSize,
         LPCSTR   *lpStrings,
         LPVOID     lpRawData
        );
    */

    /* Security Not implemented
    BOOL WINAPI DuplicateToken(
        HANDLE ExistingTokenHandle,
        SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
        PHANDLE DuplicateTokenHandle
        );

    BOOL WINAPI GetKernelObjectSecurity (
        HANDLE Handle,
        SECURITY_INFORMATION RequestedInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        DWORD nLength,
        LPDWORD lpnLengthNeeded
        );

    BOOL WINAPI ImpersonateNamedPipeClient(
        HANDLE hNamedPipe
        );

    BOOL WINAPI ImpersonateSelf(
        SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
        );


    BOOL WINAPI RevertToSelf (
        VOID
        );

    BOOL WINAPI SetThreadToken (
        PHANDLE Thread,
        HANDLE Token
        );

    BOOL WINAPI AccessCheck (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        PGENERIC_MAPPING GenericMapping,
        PPRIVILEGE_SET PrivilegeSet,
        LPDWORD PrivilegeSetLength,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus
        );


    BOOL WINAPI OpenProcessToken (
        HANDLE ProcessHandle,
        DWORD DesiredAccess,
        PHANDLE TokenHandle
        );


    BOOL WINAPI OpenThreadToken (
        HANDLE ThreadHandle,
        DWORD DesiredAccess,
        BOOL OpenAsSelf,
        PHANDLE TokenHandle
        );


    BOOL WINAPI GetTokenInformation (
        HANDLE TokenHandle,
        TOKEN_INFORMATION_CLASS TokenInformationClass,
        LPVOID TokenInformation,
        DWORD TokenInformationLength,
        PDWORD ReturnLength
        );


    BOOL WINAPI SetTokenInformation (
        HANDLE TokenHandle,
        TOKEN_INFORMATION_CLASS TokenInformationClass,
        LPVOID TokenInformation,
        DWORD TokenInformationLength
        );


    BOOL WINAPI AdjustTokenPrivileges (
        HANDLE TokenHandle,
        BOOL DisableAllPrivileges,
        PTOKEN_PRIVILEGES NewState,
        DWORD BufferLength,
        PTOKEN_PRIVILEGES PreviousState,
        PDWORD ReturnLength
        );


    BOOL WINAPI AdjustTokenGroups (
        HANDLE TokenHandle,
        BOOL ResetToDefault,
        PTOKEN_GROUPS NewState,
        DWORD BufferLength,
        PTOKEN_GROUPS PreviousState,
        PDWORD ReturnLength
        );


    BOOL WINAPI PrivilegeCheck (
        HANDLE ClientToken,
        PPRIVILEGE_SET RequiredPrivileges,
        LPBOOL pfResult
        );


    BOOL WINAPI AccessCheckAndAuditAlarmA (
        LPCSTR SubsystemName,
        LPVOID HandleId,
        LPSTR ObjectTypeName,
        LPSTR ObjectName,
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        DWORD DesiredAccess,
        PGENERIC_MAPPING GenericMapping,
        BOOL ObjectCreation,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus,
        LPBOOL pfGenerateOnClose
        );

    BOOL WINAPI ObjectOpenAuditAlarmA (
        LPCSTR SubsystemName,
        LPVOID HandleId,
        LPSTR ObjectTypeName,
        LPSTR ObjectName,
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        DWORD GrantedAccess,
        PPRIVILEGE_SET Privileges,
        BOOL ObjectCreation,
        BOOL AccessGranted,
        LPBOOL GenerateOnClose
        );

    BOOL WINAPI ObjectPrivilegeAuditAlarmA (
        LPCSTR SubsystemName,
        LPVOID HandleId,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        PPRIVILEGE_SET Privileges,
        BOOL AccessGranted
        );

    BOOL WINAPI ObjectCloseAuditAlarmA (
        LPCSTR SubsystemName,
        LPVOID HandleId,
        BOOL GenerateOnClose
        );

    BOOL WINAPI PrivilegedServiceAuditAlarmA (
        LPCSTR SubsystemName,
        LPCSTR ServiceName,
        HANDLE ClientToken,
        PPRIVILEGE_SET Privileges,
        BOOL AccessGranted
        );

    BOOL WINAPI IsValidSid (
        PSID pSid
        );


    BOOL WINAPI EqualSid (
        PSID pSid1,
        PSID pSid2
        );


    BOOL WINAPI EqualPrefixSid (
        PSID pSid1,
        PSID pSid2
        );


    DWORD WINAPI GetSidLengthRequired (
        UCHAR nSubAuthorityCount
        );


    BOOL WINAPI AllocateAndInitializeSid (
        PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
        BYTE nSubAuthorityCount,
        DWORD nSubAuthority0,
        DWORD nSubAuthority1,
        DWORD nSubAuthority2,
        DWORD nSubAuthority3,
        DWORD nSubAuthority4,
        DWORD nSubAuthority5,
        DWORD nSubAuthority6,
        DWORD nSubAuthority7,
        PSID *pSid
        );

    PVOID WINAPI FreeSid(
        PSID pSid
        );

    BOOL WINAPI InitializeSid (
        PSID Sid,
        PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
        BYTE nSubAuthorityCount
        );


    PSID_IDENTIFIER_AUTHORITY WINAPI GetSidIdentifierAuthority (
        PSID pSid
        );


    PDWORD WINAPI GetSidSubAuthority (
        PSID pSid,
        DWORD nSubAuthority
        );


    PUCHAR WINAPI GetSidSubAuthorityCount (
        PSID pSid
        );


    DWORD WINAPI GetLengthSid (
        PSID pSid
        );


    BOOL WINAPI CopySid (
        DWORD nDestinationSidLength,
        PSID pDestinationSid,
        PSID pSourceSid
        );


    BOOL WINAPI AreAllAccessesGranted (
        DWORD GrantedAccess,
        DWORD DesiredAccess
        );


    BOOL WINAPI AreAnyAccessesGranted (
        DWORD GrantedAccess,
        DWORD DesiredAccess
        );


    VOID WINAPI MapGenericMask (
        PDWORD AccessMask,
        PGENERIC_MAPPING GenericMapping
        );


    BOOL WINAPI IsValidAcl (
        PACL pAcl
        );


    BOOL WINAPI InitializeAcl (
        PACL pAcl,
        DWORD nAclLength,
        DWORD dwAclRevision
        );


    BOOL WINAPI GetAclInformation (
        PACL pAcl,
        LPVOID pAclInformation,
        DWORD nAclInformationLength,
        ACL_INFORMATION_CLASS dwAclInformationClass
        );


    BOOL WINAPI SetAclInformation (
        PACL pAcl,
        LPVOID pAclInformation,
        DWORD nAclInformationLength,
        ACL_INFORMATION_CLASS dwAclInformationClass
        );


    BOOL WINAPI AddAce (
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD dwStartingAceIndex,
        LPVOID pAceList,
        DWORD nAceListLength
        );


    BOOL WINAPI DeleteAce (
        PACL pAcl,
        DWORD dwAceIndex
        );


    BOOL WINAPI GetAce (
        PACL pAcl,
        DWORD dwAceIndex,
        LPVOID *pAce
        );


    BOOL WINAPI AddAccessAllowedAce (
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AccessMask,
        PSID pSid
        );


    BOOL WINAPI AddAccessDeniedAce (
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AccessMask,
        PSID pSid
        );


    BOOL WINAPI AddAuditAccessAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD dwAccessMask,
        PSID pSid,
        BOOL bAuditSuccess,
        BOOL bAuditFailure
        );


    BOOL WINAPI FindFirstFreeAce (
        PACL pAcl,
        LPVOID *pAce
        );


    BOOL WINAPI InitializeSecurityDescriptor (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        DWORD dwRevision
        );


    BOOL WINAPI IsValidSecurityDescriptor (
        PSECURITY_DESCRIPTOR pSecurityDescriptor
        );


    DWORD WINAPI GetSecurityDescriptorLength (
        PSECURITY_DESCRIPTOR pSecurityDescriptor
        );


    BOOL WINAPI GetSecurityDescriptorControl (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSECURITY_DESCRIPTOR_CONTROL pControl,
        LPDWORD lpdwRevision
        );


    BOOL WINAPI SetSecurityDescriptorDacl (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        BOOL bDaclPresent,
        PACL pDacl,
        BOOL bDaclDefaulted
        );


    BOOL WINAPI GetSecurityDescriptorDacl (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        LPBOOL lpbDaclPresent,
        PACL *pDacl,
        LPBOOL lpbDaclDefaulted
        );


    BOOL WINAPI SetSecurityDescriptorSacl (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        BOOL bSaclPresent,
        PACL pSacl,
        BOOL bSaclDefaulted
        );


    BOOL WINAPI GetSecurityDescriptorSacl (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        LPBOOL lpbSaclPresent,
        PACL *pSacl,
        LPBOOL lpbSaclDefaulted
        );


    BOOL WINAPI SetSecurityDescriptorOwner (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID pOwner,
        BOOL bOwnerDefaulted
        );


    BOOL WINAPI GetSecurityDescriptorOwner (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID *pOwner,
        LPBOOL lpbOwnerDefaulted
        );


    BOOL WINAPI SetSecurityDescriptorGroup (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID pGroup,
        BOOL bGroupDefaulted
        );


    BOOL WINAPI GetSecurityDescriptorGroup (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID *pGroup,
        LPBOOL lpbGroupDefaulted
        );


    BOOL WINAPI CreatePrivateObjectSecurity (
        PSECURITY_DESCRIPTOR ParentDescriptor,
        PSECURITY_DESCRIPTOR CreatorDescriptor,
        PSECURITY_DESCRIPTOR * NewDescriptor,
        BOOL IsDirectoryObject,
        HANDLE Token,
        PGENERIC_MAPPING GenericMapping
        );


    BOOL WINAPI SetPrivateObjectSecurity (
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR ModificationDescriptor,
        PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
        PGENERIC_MAPPING GenericMapping,
        HANDLE Token
        );


    BOOL WINAPI GetPrivateObjectSecurity (
        PSECURITY_DESCRIPTOR ObjectDescriptor,
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR ResultantDescriptor,
        DWORD DescriptorLength,
        PDWORD ReturnLength
        );


    BOOL WINAPI DestroyPrivateObjectSecurity (
        PSECURITY_DESCRIPTOR * ObjectDescriptor
        );


    BOOL WINAPI MakeSelfRelativeSD (
        PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
        PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
        LPDWORD lpdwBufferLength
        );


    BOOL WINAPI MakeAbsoluteSD (
        PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
        PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
        LPDWORD lpdwAbsoluteSecurityDescriptorSize,
        PACL pDacl,
        LPDWORD lpdwDaclSize,
        PACL pSacl,
        LPDWORD lpdwSaclSize,
        PSID pOwner,
        LPDWORD lpdwOwnerSize,
        PSID pPrimaryGroup,
        LPDWORD lpdwPrimaryGroupSize
        );


    BOOL WINAPI SetFileSecurityA (
        LPCSTR lpFileName,
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor
        );

    BOOL WINAPI GetFileSecurityA (
        LPCSTR lpFileName,
        SECURITY_INFORMATION RequestedInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        DWORD nLength,
        LPDWORD lpnLengthNeeded
        );

    BOOL WINAPI SetKernelObjectSecurity (
        HANDLE Handle,
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR SecurityDescriptor
        );
    */

    [
    usesgetlasterror,
    entry("FindFirstChangeNotificationA"),
    helpstring("Sets initial change notification filter conditions and returns handle to wait for change matching the filter conditions occurs in the specified directory or subtree"),
    ]
    HANDLE WINAPI FindFirstChangeNotification(
        [in] LPCSTR lpPathName,
        [in] BOOL bWatchSubtree,
        [in] DWORD dwNotifyFilter
        );

    [
    usesgetlasterror,
    entry("FindNextChangeNotification"),
    helpstring("Requests change notification for next file event matching previously set filter conditions associated handle"),
    ]
    BOOL WINAPI FindNextChangeNotification(
        [in] HANDLE hChangeHandle
        );

    [
    usesgetlasterror,
    entry("FindCloseChangeNotification"),
    helpstring("Stops file change notification filtering for the handle"),
    ]
    BOOL WINAPI FindCloseChangeNotification(
        [in] HANDLE hChangeHandle
        );

    /*
    BOOL WINAPI LookupAccountSidA(
        LPCSTR lpSystemName,
        PSID Sid,
        LPSTR Name,
        LPDWORD cbName,
        LPSTR ReferencedDomainName,
        LPDWORD cbReferencedDomainName,
        PSID_NAME_USE peUse
        );

    BOOL WINAPI LookupAccountNameA(
        LPCSTR lpSystemName,
        LPCSTR lpAccountName,
        PSID Sid,
        LPDWORD cbSid,
        LPSTR ReferencedDomainName,
        LPDWORD cbReferencedDomainName,
        PSID_NAME_USE peUse
        );

    BOOL WINAPI LookupPrivilegeValueA(
        LPCSTR lpSystemName,
        LPCSTR lpName,
        PLUID   lpLuid
        );

    BOOL WINAPI LookupPrivilegeNameA(
        LPCSTR lpSystemName,
        PLUID   lpLuid,
        LPSTR lpName,
        LPDWORD cbName
        );

    BOOL WINAPI LookupPrivilegeDisplayNameA(
        LPCSTR lpSystemName,
        LPCSTR lpName,
        LPSTR lpDisplayName,
        LPDWORD cbDisplayName,
        LPDWORD lpLanguageId
        );

    BOOL WINAPI AllocateLocallyUniqueId(
        PLUID Luid
        );
    */

    /* Miscellaneous not implemented
    VOID WINAPI SetFileApisToOEM( VOID );

    VOID WINAPI SetFileApisToANSI( VOID );

    BOOL WINAPI AreFileApisANSI( VOID );

    BOOL WINAPI SetPriorityClass(
        HANDLE hProcess,
        DWORD dwPriorityClass
        );

    DWORD WINAPI GetPriorityClass(
        HANDLE hProcess
        );

    BOOL WINAPI IsBadReadPtr(
        CONST VOID *lp,
        UINT ucb
        );

    BOOL WINAPI IsBadWritePtr(
        LPVOID lp,
        UINT ucb
        );

    BOOL WINAPI IsBadHugeReadPtr(
        CONST VOID *lp,
        UINT ucb
        );

    BOOL WINAPI IsBadHugeWritePtr(
        LPVOID lp,
        UINT ucb
        );

    BOOL WINAPI IsBadCodePtr(
        FARPROC lpfn
        );

    BOOL WINAPI IsBadStringPtrA(
        LPCSTR lpsz,
        UINT ucchMax
        );
    */

    /* Performance counter not implemented

    BOOL WINAPI QueryPerformanceCounter(
        LARGE_INTEGER *lpPerformanceCount
        );

    BOOL WINAPI QueryPerformanceFrequency(
        LARGE_INTEGER *lpFrequency
        );
    */


}

[
uuid(54674049-3A82-101B-8181-00AA003743D3),
helpstring("Win32 Base Constants"),
dllname("NOSUCH.DLL")
]
module WinBaseConst {

    [ helpstring("GetComputerName: Maximum name length") ]
    const int MAX_COMPUTERNAME_LENGTH  = 15;

    [ helpstring("Create handle functions: Invalid handle") ]
    const long INVALID_HANDLE_VALUE  = -1;
    const long INVALID_FILE_SIZE = 0xFFFFFFFF;

    /*
    const int FILE_BEGIN          = 0;
    const int FILE_CURRENT        = 1;
    const int FILE_END            = 2;

    const DWORD TIME_ZONE_ID_INVALID = 0xFFFFFFFF;
    */

    const long WAIT_FAILED          = 0xFFFFFFFF;
    const long WAIT_OBJECT_0        = 0x00000000;

    const long WAIT_ABANDONED       = 0x00000080;
    const long WAIT_ABANDONED_0     = 0x00000080;

    const long WAIT_TIMEOUT         = 0x00000102;
    const long WAIT_IO_COMPLETION   = 0x000000C0;
    const long STILL_ACTIVE         = 0x00000103;

    const long FILE_NOTIFY_CHANGE_FILE_NAME  = 0x00000001;
    const long FILE_NOTIFY_CHANGE_DIR_NAME   = 0x00000002;
    const long FILE_NOTIFY_CHANGE_ATTRIBUTES = 0x00000004;
    const long FILE_NOTIFY_CHANGE_SIZE       = 0x00000008;
    const long FILE_NOTIFY_CHANGE_LAST_WRITE = 0x00000010;
    const long FILE_NOTIFY_CHANGE_SECURITY   = 0x00000100;

    //
    // File creation flags must start at the high end since they
    // are combined with the attributes
    //

    const long FILE_FLAG_WRITE_THROUGH      = 0x80000000;
    const long FILE_FLAG_OVERLAPPED         = 0x40000000;
    const long FILE_FLAG_NO_BUFFERING       = 0x20000000;
    const long FILE_FLAG_RANDOM_ACCESS      = 0x10000000;
    const long FILE_FLAG_SEQUENTIAL_SCAN    = 0x08000000;
    const long FILE_FLAG_DELETE_ON_CLOSE    = 0x04000000;
    const long FILE_FLAG_BACKUP_SEMANTICS   = 0x02000000;
    const long FILE_FLAG_POSIX_SEMANTICS    = 0x01000000;

    const long CREATE_NEW           = 1;
    const long CREATE_ALWAYS        = 2;
    const long OPEN_EXISTING        = 3;
    const long OPEN_ALWAYS          = 4;
    const long TRUNCATE_EXISTING    = 5;

    const long GENERIC_READ         = 0x80000000;
    const long GENERIC_WRITE        = 0x40000000;
    const long GENERIC_EXECUTE      = 0x20000000;
    const long GENERIC_ALL          = 0x10000000;

    const long FILE_SHARE_READ          = 0x00000001;
    const long FILE_SHARE_WRITE         = 0x00000002;
    const long FILE_ATTRIBUTE_READONLY  = 0x00000001;
    const long FILE_ATTRIBUTE_HIDDEN    = 0x00000002;
    const long FILE_ATTRIBUTE_SYSTEM    = 0x00000004;
    const long FILE_ATTRIBUTE_DIRECTORY = 0x00000010;
    const long FILE_ATTRIBUTE_ARCHIVE   = 0x00000020;
    const long FILE_ATTRIBUTE_NORMAL    = 0x00000080;
    const long FILE_ATTRIBUTE_TEMPORARY = 0x00000100;
    const long FILE_ATTRIBUTE_COMPRESSED = 0x00000800;

    /*
    //
    // Define the NamedPipe definitions
    //

    //
    // Define the dwOpenMode values for CreateNamedPipe
    //

    const DWORD PIPE_ACCESS_INBOUND        = 0x00000001;
    const DWORD PIPE_ACCESS_OUTBOUND       = 0x00000002;
    const DWORD PIPE_ACCESS_DUPLEX         = 0x00000003;

    //
    // Define the Named Pipe End flags for GetNamedPipeInfo
    //

    const DWORD PIPE_CLIENT_END            = 0x00000000;
    const DWORD PIPE_SERVER_END            = 0x00000001;

    //
    // Define the dwPipeMode values for CreateNamedPipe
    //

    const DWORD PIPE_WAIT                  = 0x00000000;
    const DWORD PIPE_NOWAIT                = 0x00000001;
    const DWORD PIPE_READMODE_BYTE         = 0x00000000;
    const DWORD PIPE_READMODE_MESSAGE      = 0x00000002;
    const DWORD PIPE_TYPE_BYTE             = 0x00000000;
    const DWORD PIPE_TYPE_MESSAGE          = 0x00000004;

    //
    // Define the well known values for CreateNamedPipe nMaxInstances
    //

    const int PIPE_UNLIMITED_INSTANCES   = 255;
    */

    /*
    //
    // Define the Security Quality of Service bits to be passed
    // into CreateFile
    //

    //define SECURITY_ANONYMOUS         ( SecurityAnonymous      << 16 )
    //define SECURITY_IDENTIFICATION    ( SecurityIdentification << 16 )
    //define SECURITY_IMPERSONATION     ( SecurityImpersonation  << 16 )
    //define SECURITY_DELEGATION        ( SecurityDelegation     << 16 )

    const DWORD SECURITY_CONTEXT_TRACKING  = 0x00040000;
    const DWORD SECURITY_EFFECTIVE_ONLY    = 0x00080000;

    const DWORD SECURITY_SQOS_PRESENT      = 0x00100000;
    const DWORD SECURITY_VALID_SQOS_FLAGS  = 0x001F0000;
    */

    //
    //  File structures
    //

    /*
    typedef struct _OVERLAPPED {
        DWORD   Internal;
        DWORD   InternalHigh;
        DWORD   Offset;
        DWORD   OffsetHigh;
        HANDLE  hEvent;
    } OVERLAPPED, *LPOVERLAPPED;
    */

    /*
    typedef struct _SECURITY_ATTRIBUTES {
        DWORD nLength;
        LPVOID lpSecurityDescriptor;
        BOOL bInheritHandle;
    } SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
    */

    /*
    typedef struct _PROCESS_INFORMATION {
        HANDLE hProcess;
        HANDLE hThread;
        DWORD dwProcessId;
        DWORD dwThreadId;
    } PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;
    */

    //
    //  File System time stamps are represented with the following structure:
    //

    /*
    typedef struct _FILETIME {
        DWORD dwLowDateTime;
        DWORD dwHighDateTime;
    } FILETIME, *PFILETIME, *LPFILETIME;
    */

    //
    // System time is represented with the following structure:
    //

    /*
    typedef struct _SYSTEMTIME {
        WORD wYear;
        WORD wMonth;
        WORD wDayOfWeek;
        WORD wDay;
        WORD wHour;
        WORD wMinute;
        WORD wSecond;
        WORD wMilliseconds;
    } SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;
    */

    /*
    typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(
        LPVOID lpThreadParameter
        );
    typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

    typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
    typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
    typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

    typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
    typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
    typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

    #ifdef _X86_
    typedef PLDT_ENTRY LPLDT_ENTRY;
    #else
    typedef LPVOID LPLDT_ENTRY;
    #endif

    //define MUTEX_MODIFY_STATE MUTANT_QUERY_STATE
    //define MUTEX_ALL_ACCESS MUTANT_ALL_ACCESS

    /*
    typedef struct _SYSTEM_INFO {
        DWORD dwOemId;
        DWORD dwPageSize;
        LPVOID lpMinimumApplicationAddress;
        LPVOID lpMaximumApplicationAddress;
        DWORD dwActiveProcessorMask;
        DWORD dwNumberOfProcessors;
        DWORD dwProcessorType;
        DWORD dwAllocationGranularity;
        DWORD dwReserved;
    } SYSTEM_INFO, *LPSYSTEM_INFO;
    */

    /*
    typedef struct _MEMORYSTATUS {
        DWORD dwLength;
        DWORD dwMemoryLoad;
        DWORD dwTotalPhys;
        DWORD dwAvailPhys;
        DWORD dwTotalPageFile;
        DWORD dwAvailPageFile;
        DWORD dwTotalVirtual;
        DWORD dwAvailVirtual;
    } MEMORYSTATUS, *LPMEMORYSTATUS;
    */

    /*
    // dwCreationFlag values

    const DWORD DEBUG_PROCESS              = 0x00000001;
    const DWORD DEBUG_ONLY_THIS_PROCESS    = 0x00000002;

    const DWORD CREATE_SUSPENDED           = 0x00000004;

    const DWORD DETACHED_PROCESS           = 0x00000008;

    const DWORD CREATE_NEW_CONSOLE         = 0x00000010;

    const DWORD NORMAL_PRIORITY_CLASS      = 0x00000020;
    const DWORD IDLE_PRIORITY_CLASS        = 0x00000040;
    const DWORD HIGH_PRIORITY_CLASS        = 0x00000080;
    const DWORD REALTIME_PRIORITY_CLASS    = 0x00000100;

    const DWORD CREATE_NEW_PROCESS_GROUP   = 0x00000200;
    const DWORD CREATE_UNICODE_ENVIRONMENT = 0x00000400;

    const DWORD CREATE_SEPARATE_WOW_VDM    = 0x00000800;

    const DWORD CREATE_DEFAULT_ERROR_MODE  = 0x04000000;
    const DWORD CREATE_NO_WINDOW           = 0x08000000;

    //define THREAD_PRIORITY_LOWEST         THREAD_BASE_PRIORITY_MIN
    //define THREAD_PRIORITY_BELOW_NORMAL   (THREAD_PRIORITY_LOWEST+1)
    //define THREAD_PRIORITY_NORMAL         0
    //define THREAD_PRIORITY_HIGHEST        THREAD_BASE_PRIORITY_MAX
    //define THREAD_PRIORITY_ABOVE_NORMAL   (THREAD_PRIORITY_HIGHEST-1)
    //define THREAD_PRIORITY_ERROR_RETURN   (MAXLONG)

    //define THREAD_PRIORITY_TIME_CRITICAL  THREAD_BASE_PRIORITY_LOWRT
    //define THREAD_PRIORITY_IDLE           THREAD_BASE_PRIORITY_IDLE
    */

    /*
    // Debug APIs
    //
    const int EXCEPTION_DEBUG_EVENT      = 1;
    const int CREATE_THREAD_DEBUG_EVENT  = 2;
    const int CREATE_PROCESS_DEBUG_EVENT = 3;
    const int EXIT_THREAD_DEBUG_EVENT    = 4;
    const int EXIT_PROCESS_DEBUG_EVENT   = 5;
    const int LOAD_DLL_DEBUG_EVENT       = 6;
    const int UNLOAD_DLL_DEBUG_EVENT     = 7;
    const int OUTPUT_DEBUG_STRING_EVENT  = 8;
    const int RIP_EVENT                  = 9;
    */

    /*
    typedef struct _EXCEPTION_DEBUG_INFO {
        EXCEPTION_RECORD ExceptionRecord;
        DWORD dwFirstChance;
    } EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;
    */

    /*
    typedef struct _CREATE_THREAD_DEBUG_INFO {
        HANDLE hThread;
        LPVOID lpThreadLocalBase;
        LPTHREAD_START_ROUTINE lpStartAddress;
    } CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;
    */

    /*
    typedef struct _CREATE_PROCESS_DEBUG_INFO {
        HANDLE hFile;
        HANDLE hProcess;
        HANDLE hThread;
        LPVOID lpBaseOfImage;
        DWORD dwDebugInfoFileOffset;
        DWORD nDebugInfoSize;
        LPVOID lpThreadLocalBase;
        LPTHREAD_START_ROUTINE lpStartAddress;
        LPVOID lpImageName;
        WORD fUnicode;
    } CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;
    */

    /*
    typedef struct _EXIT_THREAD_DEBUG_INFO {
        DWORD dwExitCode;
    } EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;
    */

    /*
    typedef struct _EXIT_PROCESS_DEBUG_INFO {
        DWORD dwExitCode;
    } EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;
    */

    /*
    typedef struct _LOAD_DLL_DEBUG_INFO {
        HANDLE hFile;
        LPVOID lpBaseOfDll;
        DWORD dwDebugInfoFileOffset;
        DWORD nDebugInfoSize;
        LPVOID lpImageName;
        WORD fUnicode;
    } LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;
    */

    /*
    typedef struct _UNLOAD_DLL_DEBUG_INFO {
        LPVOID lpBaseOfDll;
    } UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;
    */

    /*
    typedef struct _OUTPUT_DEBUG_STRING_INFO {
        LPSTR lpDebugStringData;
        WORD fUnicode;
        WORD nDebugStringLength;
    } OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;
    */

    /*
    typedef struct _RIP_INFO {
        DWORD dwError;
        DWORD dwType;
    } RIP_INFO, *LPRIP_INFO;
    */


    /*
    typedef struct _DEBUG_EVENT {
        DWORD dwDebugEventCode;
        DWORD dwProcessId;
        DWORD dwThreadId;
        union {
            EXCEPTION_DEBUG_INFO Exception;
            CREATE_THREAD_DEBUG_INFO CreateThread;
            CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
            EXIT_THREAD_DEBUG_INFO ExitThread;
            EXIT_THREAD_DEBUG_INFO ExitProcess;
            LOAD_DLL_DEBUG_INFO LoadDll;
            UNLOAD_DLL_DEBUG_INFO UnloadDll;
            OUTPUT_DEBUG_STRING_INFO DebugString;
            RIP_INFO RipInfo;
        } u;
    } DEBUG_EVENT, *LPDEBUG_EVENT;
    */

    /*
    typedef PCONTEXT LPCONTEXT;
    typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
    typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
    */

    // GetDriveType return values
    [ helpstring("GetDriveType: Unknown drive") ]
    const int DRIVE_UNKNOWN     = 0;
    [ helpstring("GetDriveType: Invalid root drive") ]
    const int DRIVE_NO_ROOT_DIR = 1;
    [ helpstring("GetDriveType: Removable drive") ]
    const int DRIVE_REMOVABLE   = 2;
    [ helpstring("GetDriveType: Fixed drive") ]
    const int DRIVE_FIXED       = 3;
    [ helpstring("GetDriveType: Remote drive") ]
    const int DRIVE_REMOTE      = 4;
    [ helpstring("GetDriveType: CD-ROM drive") ]
    const int DRIVE_CDROM       = 5;
    [ helpstring("GetDriveType: RAM disk") ]
    const int DRIVE_RAMDISK     = 6;

    /*
    const WORD FILE_TYPE_UNKNOWN  = 0x0000;
    const WORD FILE_TYPE_DISK     = 0x0001;
    const WORD FILE_TYPE_CHAR     = 0x0002;
    const WORD FILE_TYPE_PIPE     = 0x0003;
    const WORD FILE_TYPE_REMOTE   = 0x8000;


    const int STD_INPUT_HANDLE    = -10;
    const int STD_OUTPUT_HANDLE   = -11;
    const int STD_ERROR_HANDLE    = -12;

    const DWORD NMPWAIT_WAIT_FOREVER           = 0xffffffff;
    const DWORD NMPWAIT_NOWAIT                 = 0x00000001;
    const DWORD NMPWAIT_USE_DEFAULT_WAIT       = 0x00000000;

    //define FS_CASE_IS_PRESERVED           FILE_CASE_PRESERVED_NAMES
    //define FS_CASE_SENSITIVE              FILE_CASE_SENSITIVE_SEARCH
    //define FS_UNICODE_STORED_ON_DISK      FILE_UNICODE_ON_DISK
    //define FS_PERSISTENT_ACLS             FILE_PERSISTENT_ACLS
    //define FS_VOL_IS_COMPRESSED           FILE_VOLUME_IS_COMPRESSED
    //define FS_FILE_COMPRESSION            FILE_FILE_COMPRESSION
    */

    [ helpstring("File mapping: Copy on write access") ]
    const long FILE_MAP_COPY        = 0x00000001; // SECTION_QUERY
    [ helpstring("File mapping: Read-write access") ]
    const long FILE_MAP_WRITE       = 0x00000002; // SECTION_MAP_WRITE
    [ helpstring("File mapping: Read-only access") ]
    const long FILE_MAP_READ        = 0x00000004; // SECTION_MAP_READ
    [ helpstring("File mapping: Read-write access") ]
    const long FILE_MAP_ALL_ACCESS  = 0x000F001F; // SECTION_ALL_ACCESS

    [ helpstring("File mapping: Read-only access to committed pages") ]
    const long PAGE_READONLY        = 0x02;
    [ helpstring("File mapping: Read-write access to committed pages") ]
    const long PAGE_READWRITE       = 0x04;
    [ helpstring("File mapping: Copy-on-write access to committed pages") ]
    const long PAGE_WRITECOPY       = 0x08;

    /*
    const long SEC_IMAGE            = 0x01000000;
    const long SEC_RESERVE          = 0x04000000;
    const long SEC_COMMIT           = 0x08000000;
    const long SEC_NOCACHE          = 0x10000000;

    const int OFS_MAXPATHNAME       = 128;
    */

}
#endif // WIN32
