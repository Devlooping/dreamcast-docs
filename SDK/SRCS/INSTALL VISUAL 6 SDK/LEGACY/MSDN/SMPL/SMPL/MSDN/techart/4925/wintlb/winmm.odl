
[
uuid(5467404E-3A82-101B-8181-00AA003743D3),
helpstring("Windows Multimedia Functions"),
#ifdef WIN32
dllname("WINMM.DLL")
#else
dllname("MMSYSTEM.DLL")
#endif
]
module Multimedia {

    /*
    // ******* Multimedia messages *******
    const UINT MM_JOY1MOVE        = 0x3A0;           // joystick
    const UINT MM_JOY2MOVE        = 0x3A1;
    const UINT MM_JOY1ZMOVE       = 0x3A2;
    const UINT MM_JOY2ZMOVE       = 0x3A3;
    const UINT MM_JOY1BUTTONDOWN  = 0x3B5;
    const UINT MM_JOY2BUTTONDOWN  = 0x3B6;
    const UINT MM_JOY1BUTTONUP    = 0x3B7;
    const UINT MM_JOY2BUTTONUP    = 0x3B8;

    const UINT MM_MCINOTIFY       = 0x3B9;           // MCI

    const UINT MM_WOM_OPEN        = 0x3BB;           // waveform output
    const UINT MM_WOM_CLOSE       = 0x3BC;
    const UINT MM_WOM_DONE        = 0x3BD;

    const UINT MM_WIM_OPEN        = 0x3BE;           // waveform input
    const UINT MM_WIM_CLOSE       = 0x3BF;
    const UINT MM_WIM_DATA        = 0x3C0;

    const UINT MM_MIM_OPEN        = 0x3C1;           // MIDI input
    const UINT MM_MIM_CLOSE       = 0x3C2;
    const UINT MM_MIM_DATA        = 0x3C3;
    const UINT MM_MIM_LONGDATA    = 0x3C4;
    const UINT MM_MIM_ERROR       = 0x3C5;
    const UINT MM_MIM_LONGERROR   = 0x3C6;

    const UINT MM_MOM_OPEN        = 0x3C7;           // MIDI output
    const UINT MM_MOM_CLOSE       = 0x3C8;
    const UINT MM_MOM_DONE        = 0x3C9;


    // ****** String resource number bases (internal use) *****

    const int MMSYSERR_BASE         = 0;
    const int WAVERR_BASE           = 32;
    const int MIDIERR_BASE          = 64;
    const int TIMERR_BASE           = 96;
    const int JOYERR_BASE           = 160;
    const int MCIERR_BASE           = 256;

    const int MCI_STRING_OFFSET     = 512;
    const int MCI_VD_OFFSET         = 1024;
    const int MCI_CD_OFFSET         = 1088;
    const int MCI_WAVE_OFFSET       = 1152;
    const int MCI_SEQ_OFFSET        = 1216;

    // ******* General error return values ********

    // general error return values
    const int MMSYSERR_NOERROR      = 0;                    // no error
    //define MMSYSERR_ERROR       (MMSYSERR_BASE + 1)  // unspecified error
    //define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  // device ID out of range
    //define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  // driver failed enable
    //define MMSYSERR_ALLOCATED   (MMSYSERR_BASE + 4)  // device already allocated
    //define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  // device handle is invalid
    //define MMSYSERR_NODRIVER    (MMSYSERR_BASE + 6)  // no device driver present
    //define MMSYSERR_NOMEM       (MMSYSERR_BASE + 7)  // memory allocation error
    //define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  // function isn't supported
    //define MMSYSERR_BADERRNUM   (MMSYSERR_BASE + 9)  // error value out of range
    //define MMSYSERR_INVALFLAG   (MMSYSERR_BASE + 10) // invalid flag passed
    //define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) // invalid parameter passed
    //define MMSYSERR_LASTERROR   (MMSYSERR_BASE + 11) // last error in range
    */

    // ******** Omit Installable driver support *****

    // ******* Omit Driver callback support ******

    // ******* Manufacturer and product IDs *****

    /*
    // Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS,
    // MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.

    // manufacturer IDs
    const int MM_MICROSOFT           = 1;       // Microsoft Corp.

    // product IDs
    const int MM_MIDI_MAPPER         = 1;       // MIDI Mapper
    const int MM_WAVE_MAPPER         = 2;       // Wave Mapper

    const int MM_SNDBLST_MIDIOUT     = 3;       // Sound Blaster MIDI output port
    const int MM_SNDBLST_MIDIIN      = 4;       // Sound Blaster MIDI input port
    const int MM_SNDBLST_SYNTH       = 5;       // Sound Blaster internal synthesizer
    const int MM_SNDBLST_WAVEOUT     = 6;       // Sound Blaster waveform output
    const int MM_SNDBLST_WAVEIN      = 7;       // Sound Blaster waveform input

    const int MM_ADLIB               = 9 ;      // Ad Lib-compatible synthesizer

    const int MM_MPU401_MIDIOUT      = 10;      // MPU401-compatible MIDI output port
    const int MM_MPU401_MIDIIN       = 11;      // MPU401-compatible MIDI input port

    //define MM_PC_JOYSTICK         12      // Joystick adapter
    */

    // ****** General MMSYSTEM support *******

    /*
    WORD WINAPI mmsystemGetVersion(void);
    */


    // ****** Sound support ******

    [
    #ifdef WIN32
    usesgetlasterror,
    entry("sndPlaySoundA"),
    #else
    entry("sndPlaySound"),
    #endif
    helpstring("Plays a sound pointer according to flags"),
    ]
    BOOL WINAPI sndPlaySound([in] LPSTR lpszSound, [in] UINT uFlags);

    [
    #ifdef WIN32
    usesgetlasterror,
    entry("sndPlaySoundA"),
    #else
    entry("sndPlaySound"),
    #endif
    helpstring("Plays a sound string according to flags"),
    ]
    BOOL WINAPI sndPlaySoundAsBytes([in] BYTE FAR * lpbSoundName, [in] UINT uFlags);

    [
    #ifdef WIN32
    usesgetlasterror,
    entry("sndPlaySoundA"),
    #else
    entry("sndPlaySound"),
    #endif
    helpstring("Plays a sound pointer according to flags"),
    ]
    BOOL WINAPI sndPlaySoundAsLp([in] DWORD dwSound, [in] UINT uFlags);

    // flag values for wFlags parameter
    [ helpstring("sndPlaySound: Play synchronously (default)") ]
    const UINT SND_SYNC          = 0x0000;
    [ helpstring("sndPlaySound: Play asynchronously") ]
    const UINT SND_ASYNC         = 0x0001;
    [ helpstring("sndPlaySound: Don't use default sound") ]
    const UINT SND_NODEFAULT     = 0x0002;
    [ helpstring("sndPlaySound: String parameter points to sound in memory") ]
    const UINT SND_MEMORY        = 0x0004;
    [ helpstring("sndPlaySound: Loop the sound until next sndPlaySound") ]
    const UINT SND_LOOP          = 0x0008;
    [ helpstring("sndPlaySound: Don't stop any currently playing sound") ]
    const UINT SND_NOSTOP        = 0x0010;

    // ****** Waveform audio support ******

    /*
    // waveform audio error return values
    //define WAVERR_BADFORMAT     (WAVERR_BASE + 0)    // unsupported wave format
    //define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    // still something playing
    //define WAVERR_UNPREPARED    (WAVERR_BASE + 2)    // header not prepared
    //define WAVERR_SYNC          (WAVERR_BASE + 3)    // device is synchronous
    //define WAVERR_LASTERROR     (WAVERR_BASE + 3)    // last error in range

    // waveform audio data types
    DECLARE_HANDLE(HWAVE);
    DECLARE_HANDLE(HWAVEIN);
    DECLARE_HANDLE(HWAVEOUT);
    typedef HWAVEIN FAR *LPHWAVEIN;
    typedef HWAVEOUT FAR *LPHWAVEOUT;
    typedef DRVCALLBACK WAVECALLBACK;
    typedef WAVECALLBACK FAR *LPWAVECALLBACK;

    // Omit wave callback messages

    // device ID for wave device mapper
    //define WAVE_MAPPER    (-1)

    // flags for dwFlags parameter in waveOutOpen() and waveInOpen()
    //define  WAVE_FORMAT_QUERY    0x0001
    //define  WAVE_ALLOWSYNC       0x0002

    // wave data block header
    typedef struct wavehdr_tag {
        LPSTR       lpData;                 // pointer to locked data buffer
        DWORD       dwBufferLength;         // length of data buffer
        DWORD       dwBytesRecorded;        // used for input only
        DWORD       dwUser;                 // for client's use
        DWORD       dwFlags;                // assorted flags (see defines)
        DWORD       dwLoops;                // loop control counter
        struct wavehdr_tag far *lpNext;     // reserved for driver
        DWORD       reserved;               // reserved for driver
    } WAVEHDR;
    typedef WAVEHDR       *PWAVEHDR;
    typedef WAVEHDR NEAR *NPWAVEHDR;
    typedef WAVEHDR FAR  *LPWAVEHDR;

    // flags for dwFlags field of WAVEHDR
    //define WHDR_DONE      0x00000001  // done bit
    //define WHDR_PREPARED  0x00000002  // set if this header has been prepared
    //define WHDR_BEGINLOOP 0x00000004  // loop start block
    //define WHDR_ENDLOOP   0x00000008  // loop end block
    //define WHDR_INQUEUE   0x00000010  // reserved for driver

    // waveform output device capabilities structure
    typedef struct waveoutcaps_tag {
        UINT    wMid;                  // manufacturer ID
        UINT    wPid;                  // product ID
        VERSION vDriverVersion;        // version of the driver
        char    szPname[MAXPNAMELEN];  // product name (NULL terminated string)
        DWORD   dwFormats;             // formats supported
        UINT    wChannels;             // number of sources supported
        DWORD   dwSupport;             // functionality supported by driver
    } WAVEOUTCAPS;
    typedef WAVEOUTCAPS       *PWAVEOUTCAPS;
    typedef WAVEOUTCAPS NEAR *NPWAVEOUTCAPS;
    typedef WAVEOUTCAPS FAR  *LPWAVEOUTCAPS;

    // flags for dwSupport field of WAVEOUTCAPS
    //define WAVECAPS_PITCH         0x0001   // supports pitch control
    //define WAVECAPS_PLAYBACKRATE  0x0002   // supports playback rate control
    //define WAVECAPS_VOLUME        0x0004   // supports volume control
    //define WAVECAPS_LRVOLUME      0x0008   // separate left-right volume control
    //define WAVECAPS_SYNC          0x0010

    // waveform input device capabilities structure
    typedef struct waveincaps_tag {
        UINT    wMid;                    // manufacturer ID
        UINT    wPid;                    // product ID
        VERSION vDriverVersion;          // version of the driver
        char    szPname[MAXPNAMELEN];    // product name (NULL terminated string)
        DWORD   dwFormats;               // formats supported
        UINT    wChannels;               // number of channels supported
    } WAVEINCAPS;
    typedef WAVEINCAPS       *PWAVEINCAPS;
    typedef WAVEINCAPS NEAR *NPWAVEINCAPS;
    typedef WAVEINCAPS FAR  *LPWAVEINCAPS;

    // defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
    //define WAVE_INVALIDFORMAT    0x00000000       // invalid format
    //define WAVE_FORMAT_1M08      0x00000001       // 11.025 kHz, Mono,   8-bit
    //define WAVE_FORMAT_1S08      0x00000002       // 11.025 kHz, Stereo, 8-bit
    //define WAVE_FORMAT_1M16      0x00000004       // 11.025 kHz, Mono,   16-bit
    //define WAVE_FORMAT_1S16      0x00000008       // 11.025 kHz, Stereo, 16-bit
    //define WAVE_FORMAT_2M08      0x00000010       // 22.05  kHz, Mono,   8-bit
    //define WAVE_FORMAT_2S08      0x00000020       // 22.05  kHz, Stereo, 8-bit
    //define WAVE_FORMAT_2M16      0x00000040       // 22.05  kHz, Mono,   16-bit
    //define WAVE_FORMAT_2S16      0x00000080       // 22.05  kHz, Stereo, 16-bit
    //define WAVE_FORMAT_4M08      0x00000100       // 44.1   kHz, Mono,   8-bit
    //define WAVE_FORMAT_4S08      0x00000200       // 44.1   kHz, Stereo, 8-bit
    //define WAVE_FORMAT_4M16      0x00000400       // 44.1   kHz, Mono,   16-bit
    //define WAVE_FORMAT_4S16      0x00000800       // 44.1   kHz, Stereo, 16-bit

    // general waveform format structure (information common to all formats)
    typedef struct waveformat_tag {
        WORD    wFormatTag;        // format type
        WORD    nChannels;         // number of channels (i.e. mono, stereo, etc.)
        DWORD   nSamplesPerSec;    // sample rate
        DWORD   nAvgBytesPerSec;   // for buffer estimation
        WORD    nBlockAlign;       // block size of data
    } WAVEFORMAT;
    typedef WAVEFORMAT       *PWAVEFORMAT;
    typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
    typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

    // flags for wFormatTag field of WAVEFORMAT
    //define WAVE_FORMAT_PCM    1

    // specific waveform format structure for PCM data
    typedef struct pcmwaveformat_tag {
        WAVEFORMAT  wf;
        WORD        wBitsPerSample;
    } PCMWAVEFORMAT;
    typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
    typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
    typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;

    // waveform audio function prototypes
    UINT WINAPI waveOutGetNumDevs(void);
    UINT WINAPI waveOutGetDevCaps(UINT uDeviceID, WAVEOUTCAPS FAR* lpCaps,
        UINT uSize);
    UINT WINAPI waveOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
    UINT WINAPI waveOutSetVolume(UINT uDeviceID, DWORD dwVolume);
    UINT WINAPI waveOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
    UINT WINAPI waveOutOpen(HWAVEOUT FAR* lphWaveOut, UINT uDeviceID,
        const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
    UINT WINAPI waveOutClose(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutPrepareHeader(HWAVEOUT hWaveOut,
         WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
    UINT WINAPI waveOutUnprepareHeader(HWAVEOUT hWaveOut,
        WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
    UINT WINAPI waveOutWrite(HWAVEOUT hWaveOut, WAVEHDR FAR* lpWaveOutHdr,
        UINT uSize);
    UINT WINAPI waveOutPause(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutRestart(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutReset(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutBreakLoop(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutGetPosition(HWAVEOUT hWaveOut, MMTIME FAR* lpInfo,
        UINT uSize);
    UINT WINAPI waveOutGetPitch(HWAVEOUT hWaveOut, DWORD FAR* lpdwPitch);
    UINT WINAPI waveOutSetPitch(HWAVEOUT hWaveOut, DWORD dwPitch);
    UINT WINAPI waveOutGetPlaybackRate(HWAVEOUT hWaveOut, DWORD FAR* lpdwRate);
    UINT WINAPI waveOutSetPlaybackRate(HWAVEOUT hWaveOut, DWORD dwRate);
    UINT WINAPI waveOutGetID(HWAVEOUT hWaveOut, UINT FAR* lpuDeviceID);

    DWORD WINAPI waveOutMessage(HWAVEOUT hWaveOut, UINT uMessage, DWORD dw1, DWORD dw2);

    UINT WINAPI waveInGetNumDevs(void);
    UINT WINAPI waveInGetDevCaps(UINT uDeviceID, WAVEINCAPS FAR* lpCaps,
        UINT uSize);
    UINT WINAPI waveInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
    UINT WINAPI waveInOpen(HWAVEIN FAR* lphWaveIn, UINT uDeviceID,
        const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
    UINT WINAPI waveInClose(HWAVEIN hWaveIn);
    UINT WINAPI waveInPrepareHeader(HWAVEIN hWaveIn,
        WAVEHDR FAR* lpWaveInHdr, UINT uSize);
    UINT WINAPI waveInUnprepareHeader(HWAVEIN hWaveIn,
        WAVEHDR FAR* lpWaveInHdr, UINT uSize);
    UINT WINAPI waveInAddBuffer(HWAVEIN hWaveIn,
        WAVEHDR FAR* lpWaveInHdr, UINT uSize);
    UINT WINAPI waveInStart(HWAVEIN hWaveIn);
    UINT WINAPI waveInStop(HWAVEIN hWaveIn);
    UINT WINAPI waveInReset(HWAVEIN hWaveIn);
    UINT WINAPI waveInGetPosition(HWAVEIN hWaveIn, MMTIME FAR* lpInfo,
        UINT uSize);
    UINT WINAPI waveInGetID(HWAVEIN hWaveIn, UINT FAR* lpuDeviceID);

    DWORD WINAPI waveInMessage(HWAVEIN hWaveIn, UINT uMessage, DWORD dw1, DWORD dw2);
    */


    // ****** MIDI audio support *******

    /*
    // MIDI error return values
    //define MIDIERR_UNPREPARED   (MIDIERR_BASE + 0)   // header not prepared
    //define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   // still something playing
    //define MIDIERR_NOMAP        (MIDIERR_BASE + 2)   // no current map
    //define MIDIERR_NOTREADY     (MIDIERR_BASE + 3)   // hardware is still busy
    //define MIDIERR_NODEVICE     (MIDIERR_BASE + 4)   // port no longer connected
    //define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   // invalid setup
    //define MIDIERR_LASTERROR    (MIDIERR_BASE + 5)   // last error in range

    // MIDI audio data types
    DECLARE_HANDLE(HMIDI);
    DECLARE_HANDLE(HMIDIIN);
    DECLARE_HANDLE(HMIDIOUT);
    typedef HMIDIIN FAR *LPHMIDIIN;
    typedef HMIDIOUT FAR *LPHMIDIOUT;
    typedef DRVCALLBACK MIDICALLBACK;
    typedef MIDICALLBACK FAR *LPMIDICALLBACK;
    //define MIDIPATCHSIZE  128
    typedef WORD PATCHARRAY[MIDIPATCHSIZE];
    typedef WORD FAR *LPPATCHARRAY;
    typedef WORD KEYARRAY[MIDIPATCHSIZE];
    typedef WORD FAR *LPKEYARRAY;

    // MIDI callback messages
    //define MIM_OPEN       MM_MIM_OPEN
    //define MIM_CLOSE      MM_MIM_CLOSE
    //define MIM_DATA       MM_MIM_DATA
    //define MIM_LONGDATA   MM_MIM_LONGDATA
    //define MIM_ERROR      MM_MIM_ERROR
    //define MIM_LONGERROR  MM_MIM_LONGERROR
    //define MOM_OPEN       MM_MOM_OPEN
    //define MOM_CLOSE      MM_MOM_CLOSE
    //define MOM_DONE       MM_MOM_DONE

    // device ID for MIDI mapper
    //define MIDIMAPPER    (-1)
    //define MIDI_MAPPER    (-1)

    // flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches()
    //define MIDI_CACHE_ALL     1
    //define MIDI_CACHE_BESTFIT 2
    //define MIDI_CACHE_QUERY   3
    //define MIDI_UNCACHE       4

    // MIDI output device capabilities structure
    typedef struct midioutcaps_tag {
        UINT    wMid;                  // manufacturer ID
        UINT    wPid;                  // product ID
        VERSION vDriverVersion;        // version of the driver
        char    szPname[MAXPNAMELEN];  // product name (NULL terminated string)
        UINT    wTechnology;           // type of device
        UINT    wVoices;               // # of voices (internal synth only)
        UINT    wNotes;                // max # of notes (internal synth only)
        UINT    wChannelMask;          // channels used (internal synth only)
        DWORD   dwSupport;             // functionality supported by driver
    } MIDIOUTCAPS;
    typedef MIDIOUTCAPS       *PMIDIOUTCAPS;
    typedef MIDIOUTCAPS NEAR *NPMIDIOUTCAPS;
    typedef MIDIOUTCAPS FAR  *LPMIDIOUTCAPS;

    // flags for wTechnology field of MIDIOUTCAPS structure
    //define MOD_MIDIPORT   1  // output port
    //define MOD_SYNTH      2  // generic internal synth
    //define MOD_SQSYNTH    3  // square wave internal synth
    //define MOD_FMSYNTH    4  // FM internal synth
    //define MOD_MAPPER     5  // MIDI mapper

    // flags for dwSupport field of MIDIOUTCAPS structure
    //define MIDICAPS_VOLUME         0x0001  // supports volume control
    //define MIDICAPS_LRVOLUME       0x0002  // separate left-right volume control
    //define MIDICAPS_CACHE          0x0004

    // MIDI output device capabilities structure
    typedef struct midiincaps_tag {
        UINT    wMid;                  // manufacturer ID
        UINT    wPid;                  // product ID
        VERSION vDriverVersion;        // version of the driver
        char    szPname[MAXPNAMELEN];  // product name (NULL terminated string)
    } MIDIINCAPS;
    typedef MIDIINCAPS      *PMIDIINCAPS;
    typedef MIDIINCAPS NEAR *NPMIDIINCAPS;
    typedef MIDIINCAPS FAR  *LPMIDIINCAPS;

    // MIDI data block header
    typedef struct midihdr_tag {
        LPSTR       lpData;               // pointer to locked data block
        DWORD       dwBufferLength;       // length of data in data block
        DWORD       dwBytesRecorded;      // used for input only
        DWORD       dwUser;               // for client's use
        DWORD       dwFlags;              // assorted flags (see defines)
        struct midihdr_tag far *lpNext;   // reserved for driver
        DWORD       reserved;             // reserved for driver
    } MIDIHDR;
    typedef MIDIHDR       *PMIDIHDR;
    typedef MIDIHDR NEAR *NPMIDIHDR;
    typedef MIDIHDR FAR  *LPMIDIHDR;

    // flags for dwFlags field of MIDIHDR structure
    //define MHDR_DONE      0x00000001       // done bit
    //define MHDR_PREPARED  0x00000002       // set if header prepared
    //define MHDR_INQUEUE   0x00000004       // reserved for driver

    // MIDI function prototypes
    UINT WINAPI midiOutGetNumDevs(void);
    UINT WINAPI midiOutGetDevCaps(UINT uDeviceID,
        MIDIOUTCAPS FAR* lpCaps, UINT uSize);
    UINT WINAPI midiOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
    UINT WINAPI midiOutSetVolume(UINT uDeviceID, DWORD dwVolume);
    UINT WINAPI midiOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
    UINT WINAPI midiOutOpen(HMIDIOUT FAR* lphMidiOut, UINT uDeviceID,
        DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
    UINT WINAPI midiOutClose(HMIDIOUT hMidiOut);
    UINT WINAPI midiOutPrepareHeader(HMIDIOUT hMidiOut,
        MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
    UINT WINAPI midiOutUnprepareHeader(HMIDIOUT hMidiOut,
        MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
    UINT WINAPI midiOutShortMsg(HMIDIOUT hMidiOut, DWORD dwMsg);
    UINT WINAPI midiOutLongMsg(HMIDIOUT hMidiOut,
        MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
    UINT WINAPI midiOutReset(HMIDIOUT hMidiOut);
    UINT WINAPI midiOutCachePatches(HMIDIOUT hMidiOut,
        UINT uBank, WORD FAR* lpwPatchArray, UINT uFlags);
    UINT WINAPI midiOutCacheDrumPatches(HMIDIOUT hMidiOut,
        UINT uPatch, WORD FAR* lpwKeyArray, UINT uFlags);
    UINT WINAPI midiOutGetID(HMIDIOUT hMidiOut, UINT FAR* lpuDeviceID);

    DWORD WINAPI midiOutMessage(HMIDIOUT hMidiOut, UINT uMessage, DWORD dw1, DWORD dw2);

    UINT WINAPI midiInGetNumDevs(void);
    UINT WINAPI midiInGetDevCaps(UINT uDeviceID,
        LPMIDIINCAPS lpCaps, UINT uSize);
    UINT WINAPI midiInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
    UINT WINAPI midiInOpen(HMIDIIN FAR* lphMidiIn, UINT uDeviceID,
        DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
    UINT WINAPI midiInClose(HMIDIIN hMidiIn);
    UINT WINAPI midiInPrepareHeader(HMIDIIN hMidiIn,
        MIDIHDR FAR* lpMidiInHdr, UINT uSize);
    UINT WINAPI midiInUnprepareHeader(HMIDIIN hMidiIn,
        MIDIHDR FAR* lpMidiInHdr, UINT uSize);
    UINT WINAPI midiInAddBuffer(HMIDIIN hMidiIn,
        MIDIHDR FAR* lpMidiInHdr, UINT uSize);
    UINT WINAPI midiInStart(HMIDIIN hMidiIn);
    UINT WINAPI midiInStop(HMIDIIN hMidiIn);
    UINT WINAPI midiInReset(HMIDIIN hMidiIn);
    UINT WINAPI midiInGetID(HMIDIIN hMidiIn, UINT FAR* lpuDeviceID);

    DWORD WINAPI midiInMessage(HMIDIIN hMidiIn, UINT uMessage, DWORD dw1, DWORD dw2);
    */

    // ****** Auxiliary audio support ******

    /*
    // device ID for aux device mapper
    //define AUX_MAPPER    (-1)

    // Auxiliary audio device capabilities structure
    typedef struct auxcaps_tag {
        UINT    wMid;                  // manufacturer ID
        UINT    wPid;                  // product ID
        VERSION vDriverVersion;        // version of the driver
        char    szPname[MAXPNAMELEN];  // product name (NULL terminated string)
        UINT    wTechnology;           // type of device
        DWORD   dwSupport;             // functionality supported by driver
    } AUXCAPS;
    typedef AUXCAPS       *PAUXCAPS;
    typedef AUXCAPS NEAR *NPAUXCAPS;
    typedef AUXCAPS FAR  *LPAUXCAPS;

    // flags for wTechnology field in AUXCAPS structure
    //define AUXCAPS_CDAUDIO    1      // audio from internal CD-ROM drive
    //define AUXCAPS_AUXIN     2       // audio from auxiliary input jacks

    // flags for dwSupport field in AUXCAPS structure
    //define AUXCAPS_VOLUME         0x0001  // supports volume control
    //define AUXCAPS_LRVOLUME       0x0002  // separate left-right volume control

    // auxiliary audio function prototypes
    UINT WINAPI auxGetNumDevs(void);
    UINT WINAPI auxGetDevCaps(UINT uDeviceID, AUXCAPS FAR* lpCaps, UINT uSize);
    UINT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
    UINT WINAPI auxGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);

    DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMessage, DWORD dw1, DWORD dw2);
    */


    // ********** Timer support ********

    /* Omit all except timeGetTime
    */

    [
    usesgetlasterror,
    entry("timeGetTime"),
    helpstring("Gets the time in milliseconds"),
    ]
    DWORD WINAPI timeGetTime();

    // ****** Joystick support ******

    /*
    // joystick error return values
    //define JOYERR_NOERROR       (0)                  // no error
    //define JOYERR_PARMS         (JOYERR_BASE+5)      // bad parameters
    //define JOYERR_NOCANDO       (JOYERR_BASE+6)      // request not completed
    //define JOYERR_UNPLUGGED     (JOYERR_BASE+7)      // joystick is unplugged

    // constants used with JOYINFO structure and MM_JOY* messages
    //define JOY_BUTTON1        0x0001
    //define JOY_BUTTON2        0x0002
    //define JOY_BUTTON3        0x0004
    //define JOY_BUTTON4        0x0008
    //define JOY_BUTTON1CHG     0x0100
    //define JOY_BUTTON2CHG     0x0200
    //define JOY_BUTTON3CHG     0x0400
    //define JOY_BUTTON4CHG     0x0800

    // joystick ID constants
    //define JOYSTICKID1        0
    //define JOYSTICKID2        1

    // joystick device capabilities data structure
    typedef struct joycaps_tag {
        UINT wMid;                  // manufacturer ID
        UINT wPid;                  // product ID
        char szPname[MAXPNAMELEN];  // product name (NULL terminated string)
        UINT wXmin;                 // minimum x position value
        UINT wXmax;                 // maximum x position value
        UINT wYmin;                 // minimum y position value
        UINT wYmax;                 // maximum y position value
        UINT wZmin;                 // minimum z position value
        UINT wZmax;                 // maximum z position value
        UINT wNumButtons;           // number of buttons
        UINT wPeriodMin;            // minimum message period when captured
        UINT wPeriodMax;            // maximum message period when captured
        } JOYCAPS;
    typedef JOYCAPS       *PJOYCAPS;
    typedef JOYCAPS NEAR *NPJOYCAPS;
    typedef JOYCAPS FAR  *LPJOYCAPS;

    // joystick information data structure
    typedef struct joyinfo_tag {
        UINT wXpos;                 // x position
        UINT wYpos;                 // y position
        UINT wZpos;                 // z position
        UINT wButtons;              // button states
        } JOYINFO;
    typedef JOYINFO       *PJOYINFO;
    typedef JOYINFO NEAR *NPJOYINFO;
    typedef JOYINFO FAR  *LPJOYINFO;

    // joystick function prototypes
    UINT WINAPI joyGetDevCaps(UINT uJoyID, JOYCAPS FAR* lpCaps, UINT uSize);
    UINT WINAPI joyGetNumDevs(void);
    UINT WINAPI joyGetPos(UINT uJoyID, JOYINFO FAR* lpInfo);
    UINT WINAPI joyGetThreshold(UINT uJoyID, UINT FAR* lpuThreshold);
    UINT WINAPI joyReleaseCapture(UINT uJoyID);
    UINT WINAPI joySetCapture([in] HWND hwnd hwnd, UINT uJoyID, UINT uPeriod,
        BOOL bChanged);
    UINT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);
    */


    // ****** Multimedia File I/O support *******

    /*
    // MMIO error return values
    //define MMIOERR_BASE           256
    //define MMIOERR_FILENOTFOUND   (MMIOERR_BASE + 1)  // file not found
    //define MMIOERR_OUTOFMEMORY    (MMIOERR_BASE + 2)  // out of memory
    //define MMIOERR_CANNOTOPEN     (MMIOERR_BASE + 3)  // cannot open
    //define MMIOERR_CANNOTCLOSE    (MMIOERR_BASE + 4)  // cannot close
    //define MMIOERR_CANNOTREAD     (MMIOERR_BASE + 5)  // cannot read
    //define MMIOERR_CANNOTWRITE    (MMIOERR_BASE + 6)  // cannot write
    //define MMIOERR_CANNOTSEEK     (MMIOERR_BASE + 7)  // cannot seek
    //define MMIOERR_CANNOTEXPAND   (MMIOERR_BASE + 8)  // cannot expand file
    //define MMIOERR_CHUNKNOTFOUND  (MMIOERR_BASE + 9)  // chunk not found
    //define MMIOERR_UNBUFFERED     (MMIOERR_BASE + 10) // file is unbuffered

    // MMIO constants
    //define CFSEPCHAR      '+'             // compound file name separator char.

    // MMIO data types
    typedef DWORD           FOURCC;         // a four character code
    typedef char _huge *    HPSTR;          // a huge version of LPSTR
    DECLARE_HANDLE(HMMIO);                  // a handle to an open file
    typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMessage,
                LPARAM lParam1, LPARAM lParam2);
    typedef MMIOPROC FAR *LPMMIOPROC;

    // general MMIO information data structure
    typedef struct _MMIOINFO
    {
            // general fields
            DWORD           dwFlags;        // general status flags
            FOURCC          fccIOProc;      // pointer to I/O procedure
            LPMMIOPROC      pIOProc;        // pointer to I/O procedure
            UINT            wErrorRet;      // place for error to be returned
            HTASK           htask;          // alternate local task

            // fields maintained by MMIO functions during buffered I/O
            LONG            cchBuffer;      // size of I/O buffer (or 0L)
            HPSTR           pchBuffer;      // start of I/O buffer (or NULL)
            HPSTR           pchNext;        // pointer to next byte to read/write
            HPSTR           pchEndRead;     // pointer to last valid byte to read
            HPSTR           pchEndWrite;    // pointer to last byte to write
            LONG            lBufOffset;     // disk offset of start of buffer

            // fields maintained by I/O procedure
            LONG            lDiskOffset;    // disk offset of next read or write
            DWORD           adwInfo[3];     // data specific to type of MMIOPROC

            // other fields maintained by MMIO
            DWORD           dwReserved1;    // reserved for MMIO use
            DWORD           dwReserved2;    // reserved for MMIO use
            HMMIO           hmmio;          // handle to open file
    } MMIOINFO;
    typedef MMIOINFO       *PMMIOINFO;
    typedef MMIOINFO NEAR *NPMMIOINFO;
    typedef MMIOINFO FAR  *LPMMIOINFO;

    // RIFF chunk information data structure
    typedef struct _MMCKINFO
    {
            FOURCC          ckid;           // chunk ID
            DWORD           cksize;         // chunk size
            FOURCC          fccType;        // form type or list type
            DWORD           dwDataOffset;   // offset of data portion of chunk
            DWORD           dwFlags;        // flags used by MMIO functions
    } MMCKINFO;
    typedef MMCKINFO       *PMMCKINFO;
    typedef MMCKINFO NEAR *NPMMCKINFO;
    typedef MMCKINFO FAR  *LPMMCKINFO;

    // bit field masks
    //define MMIO_RWMODE    0x00000003      // open file for reading/writing/both
    //define MMIO_SHAREMODE 0x00000070      // file sharing mode number

    // constants for dwFlags field of MMIOINFO
    //define MMIO_CREATE    0x00001000      // create new file (or truncate file)
    //define MMIO_PARSE     0x00000100      // parse new file returning path
    //define MMIO_DELETE    0x00000200      // create new file (or truncate file)
    //define MMIO_EXIST     0x00004000      // checks for existence of file
    //define MMIO_ALLOCBUF  0x00010000      // mmioOpen() should allocate a buffer
    //define MMIO_GETTEMP   0x00020000      // mmioOpen() should retrieve temp name

    //define MMIO_DIRTY     0x10000000      // I/O buffer is dirty


    // read/write mode numbers (bit field MMIO_RWMODE)
    //define MMIO_READ      0x00000000      // open file for reading only
    //define MMIO_WRITE     0x00000001      // open file for writing only
    //define MMIO_READWRITE 0x00000002      // open file for reading and writing

    // share mode numbers (bit field MMIO_SHAREMODE)
    //define MMIO_COMPAT    0x00000000      // compatibility mode
    //define MMIO_EXCLUSIVE 0x00000010      // exclusive-access mode
    //define MMIO_DENYWRITE 0x00000020      // deny writing to other processes
    //define MMIO_DENYREAD  0x00000030      // deny reading to other processes
    //define MMIO_DENYNONE  0x00000040      // deny nothing to other processes

    // various MMIO flags
    //define MMIO_FHOPEN            0x0010  // mmioClose: keep file handle open
    //define MMIO_EMPTYBUF          0x0010  // mmioFlush: empty the I/O buffer
    //define MMIO_TOUPPER           0x0010  // mmioStringToFOURCC: to u-case
    //define MMIO_INSTALLPROC   0x00010000  // mmioInstallIOProc: install MMIOProc
    //define MMIO_GLOBALPROC    0x10000000  // mmioInstallIOProc: install globally
    //define MMIO_REMOVEPROC    0x00020000  // mmioInstallIOProc: remove MMIOProc
    //define MMIO_FINDPROC      0x00040000  // mmioInstallIOProc: find an MMIOProc
    //define MMIO_FINDCHUNK         0x0010  // mmioDescend: find a chunk by ID
    //define MMIO_FINDRIFF          0x0020  // mmioDescend: find a LIST chunk
    //define MMIO_FINDLIST          0x0040  // mmioDescend: find a RIFF chunk
    //define MMIO_CREATERIFF        0x0020  // mmioCreateChunk: make a LIST chunk
    //define MMIO_CREATELIST        0x0040  // mmioCreateChunk: make a RIFF chunk


    // message numbers for MMIOPROC I/O procedure functions
    //define MMIOM_READ     MMIO_READ       // read
    //define MMIOM_WRITE    MMIO_WRITE      // write
    //define MMIOM_SEEK             2       // seek to a new position in file
    //define MMIOM_OPEN             3       // open file
    //define MMIOM_CLOSE            4       // close file
    //define MMIOM_WRITEFLUSH       5       // write and flush

    //define MMIOM_RENAME           6       // rename specified file

    //define MMIOM_USER        0x8000       // beginning of user-defined messages

    // standard four character codes
    //define FOURCC_RIFF    mmioFOURCC('R', 'I', 'F', 'F')
    //define FOURCC_LIST    mmioFOURCC('L', 'I', 'S', 'T')

    // four character codes used to identify standard built-in I/O procedures
    //define FOURCC_DOS     mmioFOURCC('D', 'O', 'S', ' ')
    //define FOURCC_MEM     mmioFOURCC('M', 'E', 'M', ' ')

    // flags for mmioSeek()

    // other constants
    //define MMIO_DEFAULTBUFFER     8192    // default buffer size

    // MMIO macros
    //define mmioFOURCC( ch0, ch1, ch2, ch3 )                               \
                    ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                    ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

    // MMIO function prototypes
    FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
    LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc,
        DWORD dwFlags);
    HMMIO WINAPI mmioOpen(LPSTR szFileName, MMIOINFO FAR* lpmmioinfo,
        DWORD dwOpenFlags);

    UINT WINAPI mmioRename(LPCSTR szFileName, LPCSTR szNewFileName,
         MMIOINFO FAR* lpmmioinfo, DWORD dwRenameFlags);

    UINT WINAPI mmioClose(HMMIO hmmio, UINT uFlags);
    LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
    LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
    LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
    UINT WINAPI mmioGetInfo(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
    UINT WINAPI mmioSetInfo(HMMIO hmmio, const MMIOINFO FAR* lpmmioinfo, UINT uFlags);
    UINT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
        UINT uFlags);
    UINT WINAPI mmioFlush(HMMIO hmmio, UINT uFlags);
    UINT WINAPI mmioAdvance(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
    LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMessage,
        LPARAM lParam1, LPARAM lParam2);
    UINT WINAPI mmioDescend(HMMIO hmmio, MMCKINFO FAR* lpck,
        const MMCKINFO FAR* lpckParent, UINT uFlags);
    UINT WINAPI mmioAscend(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);
    UINT WINAPI mmioCreateChunk(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);
    */

    // ****** Omit All MCI support *******

    // ****** DISPLAY Driver extensions ******

    /*
        //define QUERYROPSUPPORT 40         // use to determine ROP support
    */

    // ****** DIB Driver extensions ********

    //define SELECTDIB      41                      // DIB.DRV select dib escape
    //define DIBINDEX(n)    MAKELONG((n),0x10FF)


    // ****** ScreenSaver support *******

    // The current application will receive a syscommand of SC_SCREENSAVE just
    // before the screen saver is invoked.  If the app wishes to prevent a
    // screen save, return non-zero value, otherwise call DefWindowProc().

        //define SC_SCREENSAVE  0xF140
}
