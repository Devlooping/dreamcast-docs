// VBUTIL.ODL

[
uuid(FFDB1170-7124-11CE-8CED-00AA004A5C59),
lcid (9),
helpstring("Visual Basic Utilities"),
version(1.0)
]

library VBUTIL
{
    // Include standard windows types
    #include <oletype.odl>

    [
    uuid(FFDB1171-7124-11CE-8CED-00AA004A5C59),
    helpstring("Visual Basic Helpers"),
    dllname("VBUTIL32.DLL")
    ]
    module VBHelpers {

        [
        entry("GetFullPath"),
        usesgetlasterror,
        helpstring("Returns the full path string for sPath and fills the iFilePart, iDirPart, and iExtPart string indexes"),
        ]
        BSTR WINAPI GetFullPath([in] BSTR bsPath,
                                [in, out, optional] VARIANT * pvFilePart,
                                [in, out, optional] VARIANT * pvExtPart,
                                [in, out, optional] VARIANT * pvDirPart);

        [
        entry("GetTempFile"),
        usesgetlasterror,
        helpstring("Returns name of a unique file with sPrefix for directory sPath"),
        ]
        BSTR WINAPI GetTempFile([in] BSTR bsPath,
                                [in] BSTR bsPrefix);

        [
        entry("GetTempDir"),
        usesgetlasterror,
        helpstring("Returns the directory for temporary"),
        ]
        BSTR WINAPI GetTempDir(VOID);

		//@B SearchDirs
        [
        entry("SearchDirs"),
        usesgetlasterror,
        helpstring("Searches sPath for sFile with sExt; returns full path result and fills the iFilePart, iDirPart, and iExtPart string indexes"),
        ]
        BSTR WINAPI SearchDirs([in] BSTR bsFile,
                               [in, optional] VARIANT vExt,
                               [in, optional] VARIANT vPath,
                               [in, out, optional] VARIANT * pvFilePart,
                               [in, out, optional] VARIANT * pvExtPart,
                               [in, out, optional] VARIANT * pvDirPart);
		//@E SearchDirs

        // Unsigned integer functions

        [
        entry("LoByte"),
        helpstring("Returns the low byte of a word"),
        ]
        BYTE WINAPI LoByte([in] WORD w);

        [
        entry("HiByte"),
        helpstring("Returns the high byte of a word"),
        ]
        BYTE WINAPI HiByte([in] WORD w);

        [
        entry("LoWord"),
        helpstring("Returns the low word of a DWord"),
        ]
        WORD WINAPI LoWord([in] DWORD dw);

        [
        entry("HiWord"),
        helpstring("Returns the high word of a DWord"),
        ]
        WORD WINAPI HiWord([in] DWORD dw);

        [
        entry("MakeWord"),
        helpstring("Returns a word from two passed bytes"),
        ]
        WORD WINAPI MakeWord([in] WORD wHi, [in] WORD wLo);

		//@B MakeDWord
        [
        entry("MakeDWord"),
        helpstring("Returns a DWord from two passed words"),
        ]
        DWORD WINAPI MakeDWord([in] DWORD dwHi, [in] DWORD dwLo);
		//@E MakeDWord

        [
        entry("RShiftWord"),
        helpstring("Shifts a word right a given number of bits"),
        ]
        WORD WINAPI RShiftWord([in] WORD w, [in] WORD c);

        [
        entry("LShiftWord"),
        helpstring("Shifts a word left a given number of bits"),
        ]
        WORD WINAPI LShiftWord([in] WORD w, [in] WORD c);

        [
        entry("RShiftDWord"),
        helpstring("Shifts a DWord right a given number of bits"),
        ]
        DWORD WINAPI RShiftDWord([in] DWORD dw, [in] WORD c);

        [
        entry("LShiftDWord"),
        helpstring("Shifts a DWord left a given number of bits"),
        ]
        DWORD WINAPI LShiftDWord([in] DWORD dw, [in] WORD c);

        [
        entry("ExistFile"),
        helpstring("Returns true if the given file exists"),
        ]
		//@B ExistFile
        Boolean WINAPI ExistFile([in] LPSTR lpFileName);
		//@E ExistFile

        [
        entry("InStrR"),
        helpstring("Searches a string backward"),
        ]
		//@B InStrR
        Long WINAPI InStrR([in] Variant vStart, 
						   [in] Variant vTarget, 
						   [in, optional] Variant vFind, 
						   [in, optional] Variant vCompare);
		//@E InStrR

        [
        entry("TestBStr"),
        helpstring("Tests system BSTR functions"),
        ]
        void WINAPI TestBStr();

        [
        entry("TestBStrArgs"),
        helpstring("Tests [in], [out], and [in,out] BSTR arguments"),
        ]
        BSTR WINAPI TestBStrArgs([in] BCSTR bsIn,
                                 [in, out] BSTR * pbsInOut,
                                 [out] BSTR * pbsOut);

		//@B TestString
        [
        entry("TestString"),
        helpstring("Returns modified BSTR manipulated with String type"),
        ]
        BSTR WINAPI TestString([in] BCSTR bsIn,
                               [in, out] BSTR * pbsInOut,
                               [out] BSTR * pbsOut);
		//@E TestString

        [
        entry("TestVariant"),
        helpstring("Returns modified Variant manipulated with Variant type"),
        ]
        Variant WINAPI TestVariant([in] VARIANT vIn, 
								   [in, out] VARIANT * vInOut, 
								   [out] VARIANT * vOut);

        [
        entry("TestSA"),
        helpstring("Tests SAFEARRAY structure"),
        ]
        Variant WINAPI TestSA([in, out] SAFEARRAY(short) * ppsaiInOut, 
							  [out] SAFEARRAY(BSTR) * ppsasOut);

        [
        entry("TestSafeArray"),
        helpstring("Tests SafeArray type"),
        ]

		#if 0
		//@B TestSafeArrayProto2
        Variant WINAPI TestSafeArray([in, out] SAFEARRAY(short) * ai, 
									 [out] SAFEARRAY(BSTR) * as);
		//@E TestSafeArrayProto2
		#else
		//@B TestSafeArrayProto1
        Variant WINAPI TestSafeArray([in, out] ArrayInteger ai, 
									 [out] ArrayString as);
		//@E TestSafeArrayProto1
		#endif

		//@B AddEmUp
        [
        entry("AddEmUp"),
        helpstring("Tests ParamArrays"),
        vararg
        ]
        double WINAPI AddEmUp([in] ParamArray params);
		//@E AddEmUp
    }
}
